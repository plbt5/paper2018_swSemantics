{\rtf1\ansi\ansicpg1252\uc1\deff0
{\fonttbl{\f0\fmodern\fcharset0\fprq2 CourierNewPSMT;}{\f1\fmodern\fcharset0\fprq2 CourierNewPS-ItalicMT;}}
{\colortbl;\red0\green0\blue0;\red255\green255\blue255;}
\paperw12240\paperh15840\margl1800\margr1800\margt1440\margb1440\fet2\ftnbj\aenddoc
\pgnrestart\pgnstarts0
\pard\plain \ltrch\loch {\f0\fs24\b0\i0 We take the position that software essentially represents a token-based machine without the ability to close the gap between token and reality. This }{\f1\fs24\b0\i1 Grounding Problem}{\f0\fs24\b0\i0  [@Harnad1990], a fundamental issue in software engineering about semantics, is hardly addressed [@Steels:2008tr], if at all [@Cregan2007]. This implies that the semiotic triangle is denied its conceptualisation vertex, and the sign remains incomplete. This is confirmed by the software engineering discipline, since it consistently speaks of \loch\af0\hich\af0\dbch\af0\uc1\u8216\'91models that represent reality\u8217\'92 in a certain purposeful context }{\f1\fs24\b0\i1 without}{\f0\fs24\b0\i0  factoring the conceptualisation into the equation [@A\loch\af0\hich\af0\dbch\af0\uc1\u223\'DFmann2006]. The first consequence is that the edges about abstraction and subjectivation remain vague or necessarily conflate on the relationship between the model and reality, depicted in \\cref\{fig:software-models-reality\}. The next consequence is that the sign becomes \u8220\'93beheaded\u8221\'94, cutting-off our \u8220\'93knowledge about our given remark or doctrine\u8221\'94 [@Quine:1953er], making it impossible to perform semeiosis anymore. Yet, we make do with weak AI [@Searle:1980hw] and therefore with this beheaded sign necessarily, and must conclude that contemporary software agents can never genuinely perform semiotics.  }
\par\plain \f0\fs24\b0\i0
\par\pard\plain \ri-16872\ql\ltrch\loch {\f0\fs24\b0\i0 ![Software engineering applies a beheaded semiotic triangle in which its edges remain vague or conflate in the single relation between model and reality.][def:softmodelsreal]}
\par\plain \f0\fs24\b0\i0
\par\pard\plain \ql\ltrch\loch {\f0\fs24\b0\i0 Using current software, semantics exist only by grace of the software engineer (at the modelling stage) and the end user (during operations). The end user at the human-machine interface performs the semeiosis by interpreting the tokens that are displayed (}{\f1\fs24\b0\i1 subjectivation}{\f0\fs24\b0\i0 ). In contemporary software development, the human software engineer performs the semeiosis and all models are }{\f1\fs24\b0\i1 representations}{\f0\fs24\b0\i0  of this engineer\loch\af0\hich\af0\dbch\af0\uc1\u8217\'92s conceptualisations. Despite the inability of software to perform semeiosis, the software agent still acts as transport medium for the semantics: from the semantics as it was intended by the software engineer to the semantics as it is experienced by the end user at the human-machine interface. The core question then becomes what is required in a software agent to properly accomplish its role as semantic vehicle while it is itself incapable of comprehension. In responding to this question, we consider the many models that populate a software architecture and look for those that represent, somehow, the semantic meaning and pragmatic meaning because these are both involved in formulating semantics. Clearly, the models that carry the semantic meaning are the }{\field{\*\fldinst HYPERLINK "scrivcmt://B276A47B-7D35-4DC8-8ADD-2D643EBF17E3"}{\fldrslt\f0\fs24\b0\i0 information or data models}}{\f0\fs24\b0\i0 , since these represent the semantics as intended by the software engineer. The pragmatic meaning inheres in the data }{\field{\*\fldinst HYPERLINK "scrivcmt://24C23001-8220-4669-AFED-3DA3C49B76E4"}{\fldrslt\f0\fs24\b0\i0 processing models}}{\f0\fs24\b0\i0 , since these address the elements or values from the data models, process them and arrive at conclusions that are used to direct the process. Despite the agent\loch\af0\hich\af0\dbch\af0\uc1\u8217\'92s inability for semeiosis, the reciprocity between data and software code determines the semantic validity of the agent\u8217\'92s behaviour: the (values of) data influence the behaviour of the software code, whereas the way how the software code acts on the data influences how they refer to reality. For instance, consider a data token $T_d$ with value \\token\{t = 40.3\} to represent temperature, and a data process token $T_p$ to establish fever, e.g., \\token\{t > 37.0\} $\\to$ \\token\{fever\}. The one and only means to keep the software from failing is that both the data and the process apply identical background knowledge, such as the same (i) unit of dimension ($\\si\{\\degree\}C$ in this example), (ii) resolution and (iii) accuracy, to name a few obvious aspects about the value, and (iv) the fact that this particular data token represents a }{\f1\fs24\b0\i1 quality}{\f0\fs24\b0\i0  that inheres on a particular }{\f1\fs24\b0\i1 substance}{\f0\fs24\b0\i0 , and (v) the particular substance being a human as opposed to a cat (which possesses a higher criterion for fever), to name a few obvious ontological aspects. Furthermore, \\token\{fever\} is yet another data token that should be incorporated in the data model, e.g., a }{\f1\fs24\b0\i1 phase}{\f0\fs24\b0\i0  in the life of a human when the body temperature is above a reference range. Finally, note that because any token is part of a sign that addresses an }{\f1\fs24\b0\i1 entity}{\f0\fs24\b0\i0 , the token itself can be an atomic thing, e.g., a single data element, or a compound thing, e.g., a complex data model.   }
\par\plain \f0\fs24\b0\i0
\par\plain {\f0\fs24\b0\i0 We conclude that whereas semantics can only emerge from software by virtue of the semeiosis by the human-in-the-loop, in the software agent itself semantics are necessarily reduced to the reciprocity between data and software code. We reflect this essential disposition with the following definitions:  }
\par\plain \f0\fs24\b0\i0
\par\plain {\f0\fs24\b0\i0 \\begin\{mmdef\}[Semantic meaning]\\label\{def:semantic-meaning\}}
\par\plain {\f0\fs24\b0\i0 The semantic meaning refers to the explanation by the code model on how tokens refer to entities in reality, and particularly to the representation that is given to a germane entity. Such representation is connected to a concept or individual from the conceptualisation by means of its underlying formal semantics. Consequently, the semantic meaning is bound by the underlying formal semantics.}
\par\plain {\f0\fs24\b0\i0 \\end\{mmdef\}}
\par\plain {\f0\fs24\b0\i0 The pragmatic meaning refers to the explanation by the inferential model that comprehension refers to a process which infers the consequences of the semantic meaning. }
\par\plain {\f0\fs24\b0\i0 \\begin\{mmdef\}[Pragmatic meaning]\\label\{def:pragmatic-meaning\}}
\par\plain {\f0\fs24\b0\i0 By its underlying logic, pragmatic meaning constitutes inference patterns which augments our frame of reference from an initial (set of) fact(s), its premises. Consequently, the expressiveness of the reference framework is bound by power of the underlying logic, whereas its conclusiveness is determined by the capability of the formulated inference rules. }
\par\plain {\f0\fs24\b0\i0 \\end\{mmdef\}}
\par\plain \f0\fs24\b0\i0
\par\plain {\f0\fs24\b0\i0 These two definitions identify two aspects of the agent that are closely related, and often not even distinguished from each other, but together constitute the core of the agent\loch\af0\hich\af0\dbch\af0\uc1\u8217\'92s capability to act as vehicle for semantics. From an architectural perspective it is relevant to (i) make the distinction between both since each of them consolidates a separate concern about software semantics, and (ii) make the connection between them since, together, they alone are responsible for a consistent interpretation on data.}
\par\plain \f0\fs24\b0\i0
\par\plain {\f0\fs24\b0\i0 \\begin\{mmdef\}[Atomic semantic monolith]\\label\{def:atomic-semantic-monolith\}}
\par\plain {\f0\fs24\b0\i0 An Atomic Semantic Monolith (ASM) encapsulates a pair of tokens, $\\pair\{T_d, T_p\}$, that constitutes the reciprocity between data and software code as a reduced form of semantics, where:}
\par\plain {\f0\fs24\b0\i0 \\begin\{itemize\}}
\par\plain {\f0\fs24\b0\i0   \\item $T_d$, the data token, carries the \\emph\{semantic\} meaning;}
\par\plain {\f0\fs24\b0\i0   \\item $T_p$, the data processing token, carries the \\emph\{pragmatic\} meaning. }
\par\plain {\f0\fs24\b0\i0 \\end\{itemize\}}
\par\plain {\f0\fs24\b0\i0 Reciprocity denotes the degree with which the collective outcome of processing all potential data tokens by the process token refers to the intended states of affairs in reality. Atomicity refers to the level of granularity at which the entity that is referred to by the data token is considered a non-dividable whole. }
\par\plain {\f0\fs24\b0\i0 \\end\{mmdef\}}
\par\plain \f0\fs24\b0\i0
\par\plain {\f0\fs24\b0\i0 We consider the coherence between data models and data processing models essential for enforcing the software agent to maintain a semantic valid reciprocity between binary code and the data it operates on. Indeed, the resulting semantic monolith is not a new phenomenon in software agents. In fact one can consider each and every piece of software, including its data schema, a semantic monolith. In a broader context, a semantic message standard essentially builds a homogeneous semantic meaning to be shared by all participating software agents; the pragmatic meaning is then left as an exercise to the software engineer who is responsible for designing data processing models that effectuate the required valid reciprocity. Nevertheless, a semantic monolith emerges. Such monolith is often regarded with ambivalence: on the one hand it realises a stable groundwork that is necessary for the realisation of agent\loch\af0\hich\af0\dbch\af0\uc1\u8217\'92s abilities on, e.g., semantic interoperability, consistency and reusability; on the other hand, the semantic monolith itself is a consequential byproduct that shows major inflexibility and huge impedance to contextual or behavioural changes, the very reason for abandoning monoliths in software engineering. We defend that an architecture should not accept the emergence of a monolith as a consequence but instead present design choices as to its effectiveness and the potential consequences on the software agent\u8217\'92s -ilities. We consider the size of the semantic monolith an influential parameter in establishing an optimal balance between semantics and monolithic consequences, and therefore address atomicity as an important characteristic.}
\par\plain \f0\fs24\b0\i0
\par\plain {\f0\fs24\b0\i0 A few words on the contents of both models. In order for the data model to carry the semantic meaning, it needs to specify the concepts, their taxonomy including completeness and disjointness, the relations between them, and the values and the types of value that apply. In doing so, it provides the representation of all germane entities in the DoA, their structural relations, and the means to validate what can be stated. In order for the data processing model to carry the pragmatic meaning, it needs to specify all logical, physical or business rules that are used to draw conclusions from individual facts, as well as constraints that should apply when executing those rules. In doing so it determines the consequences of a given observation from our domain of application, completing the state of affairs. Together, they not only *specify* the representation and determination of the state of affairs, they also *represent* the actual state of affairs, turning the data into a faithful reflection of the domain of application.     }
\par\plain \f0\fs24\b0\i0
\par\plain {\f0\fs24\b0\i0 What is meant with coherence and how to enforce such is explained in the next section.}
\par\plain \f0\fs24\b0\i0
\par\plain {\f0\fs24\b0\i0 <!-- page additions -->}
\par\pard\plain \ri-10760\ql\ltrch\loch {\f0\fs24\b0\i0 [def:softmodelsreal]: src\\images\\SoftwareModelsReality.png \{#fig:software-models-reality\}}
\par\plain \f0\fs24\b0\i0}