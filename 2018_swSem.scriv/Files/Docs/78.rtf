{\rtf1\ansi\ansicpg1252\uc1\deff0
{\fonttbl{\f0\fmodern\fcharset0\fprq2 CourierNewPSMT;}{\f1\fmodern\fcharset0\fprq2 CourierNewPS-ItalicMT;}}
{\colortbl;\red0\green0\blue0;\red255\green255\blue255;}
\paperw12240\paperh15840\margl1800\margr1800\margt1440\margb1440\fet2\ftnbj\aenddoc
\pgnrestart\pgnstarts0
\pard\plain \ltrch\loch {\f0\fs24\b0\i0 We take the position that software essentially represents a token-based machine without the ability to close the gap between token and reality. This }{\f1\fs24\b0\i1 Grounding Problem}{\f0\fs24\b0\i0  [@Harnad1990], a fundamental issue in software engineering about semantics, is hardly addressed [@Steels:2008tr], if at all [@Cregan2007]. This implies that in software the semiotic triangle is denied its conceptualisation vertex, and the sign remains incomplete. This is confirmed implicitly by the software engineering discipline, since it consistently speaks of \loch\af0\hich\af0\dbch\af0\uc1\u8216\'91models that represent reality\u8217\'92 in a certain purposeful context }{\f1\fs24\b0\i1 without}{\f0\fs24\b0\i0  factoring the conceptualisation into the equation [@A\loch\af0\hich\af0\dbch\af0\uc1\u223\'DFmann2006]. The first consequence is that the edges about abstraction and subjectivation remain vague and necessarily conflate on the relationship between the model and reality, depicted in \\cref\{fig:software-models-reality\}. The next consequence is that the sign becomes \u8220\'93beheaded\u8221\'94, cutting-off our \u8220\'93knowledge about our given remark or doctrine\u8221\'94 [@Quine:1953er], making it impossible to perform semeiosis anymore. Yet, we make do with weak AI [@Searle:1980hw] and therefore with this beheaded sign necessarily, and must conclude that contemporary software agents can never genuinely perform semiotics.  }
\par\plain \f0\fs24\b0\i0
\par\pard\plain \ri-16872\ql\ltrch\loch {\f0\fs24\b0\i0 ![Software engineering applies a beheaded semiotic triangle in which its edges remain vague or conflate in the single relation between model and reality.][def:softmodelsreal]}
\par\plain \f0\fs24\b0\i0
\par\pard\plain \ql\ltrch\loch {\f0\fs24\b0\i0 Consequently, semantics exists only by grace of the software engineer (at the modelling stage) and the end user (during operations). The end user at the human-machine interface performs the semeiosis by interpreting the tokens that are displayed (}{\f1\fs24\b0\i1 subjectivation}{\f0\fs24\b0\i0 ). In contemporary software development, the human software engineer performs the semeiosis and all models are }{\f1\fs24\b0\i1 representations}{\f0\fs24\b0\i0  of this engineer\loch\af0\hich\af0\dbch\af0\uc1\u8217\'92s conceptualisations. Despite the inability of software to perform semeiosis, the software agent still acts as transport medium for semantics: from the semantics as it was intended by the software engineer to the semantics as it is experienced by the end user at the human-machine interface, as well as between end-users when collaborating by means of the software agent. The core question then becomes what is required in a software agent to properly accomplish its role as semantic vehicle while it is itself incapable of comprehension. }
\par\plain \f0\fs24\b0\i0
\par\plain {\f0\fs24\b0\i0 Despite the agent\loch\af0\hich\af0\dbch\af0\uc1\u8217\'92s inability for semeiosis, the reciprocity between data and data processing code determines the semantic validity of the agent\u8217\'92s operation: the (values of) data influence the outcome of the data processing code that operates on them while, vice versa, the particular way how the data is processed determines the conclusions that are drawn and represented as data tokens. For instance, consider a data token $T_d$ with value \\token\{t = 40.3\} to represent [|temperature], and a data process token $T_p$ to establish [|fever], e.g., \\token\{t > 37.0\} $\\to$ \\token\{fever\}. The one and only means to keep the software from failing to refer to a valid state of affairs is that both the data and the process apply identical background knowledge, such as the same (i) unit of dimension ($\\si\{\\degree\}C$ in this example), (ii) resolution and (iii) accuracy, to name a few obvious aspects about the value, and (iv) the fact that this particular data token represents a }{\f1\fs24\b0\i1 quality}{\f0\fs24\b0\i0  that inheres on a particular }{\f1\fs24\b0\i1 substance}{\f0\fs24\b0\i0 , and (v) the particular substance being human as opposed to cats (which possess a higher criterion for fever), to name a few obvious ontological aspects. Furthermore, \\token\{fever\} is yet another data token that should be incorporated in the domain model, e.g., a }{\f1\fs24\b0\i1 phase}{\f0\fs24\b0\i0  in the life of a human when the body temperature is above a reference range.    }
\par\plain \f0\fs24\b0\i0
\par\plain {\f0\fs24\b0\i0 In conclusion, the existence of the grounding problem is due to inevitable incapability of a software agent to perform semeiosis: Whereas semantics can only }{\f1\fs24\b0\i1 emerge}{\f0\fs24\b0\i0  from software by virtue of (the semeiosis by) the human-in-the-loop, in the software agent itself semantics are necessarily reduced to the reciprocity between data and software code. And since it is an essential characteristic of software to process data, the reciprocity between data and processing code exists inevitably. This results in the following design principle to its effect:}
\par\pard\plain \ri-16946\ltrch\loch \f0\fs24\b0\i0
\par\pard\plain \ri-16946\ql\ltrch\loch {\f0\fs24\b0\i0 \\begin\{mmdp\}[Semantic reciprocity principle]\\label\{dp:reciprocity\}}
\par\plain \f0\fs24\b0\i0
\par\plain {\f0\fs24\b0\i0 In software, semantics reduces to the reciprocity between data and software code.     }
\par\plain {\f0\fs24\b0\i0  }
\par\pard\plain \ri-16946\ltrch\loch {\f0\fs24\b0\i0 \\textbf\{Type of information:\} business  \\\\}
\par\plain {\f0\fs24\b0\i0 \\textbf\{Quality attributes:\} Functionality, Reliability, Usability, Maintainability, Portability  \\\\}
\par\plain {\f0\fs24\b0\i0 \\textbf\{Rationale:\}}
\par\plain {\f0\fs24\b0\i0 \\begin\{enumerate\}}
\par\plain {\f0\fs24\b0\i0   \\item Software essentially represents a token-based machine without the ability to close the gap with entities in reality; }
\par\plain {\f0\fs24\b0\i0   \\item Since software inherently process data, the reciprocity between data and data processing code applies necessarily;}
\par\plain {\f0\fs24\b0\i0   \\item By acting on data (tokens), combining them and producing new data (tokens), data processing creates, updates or deletes data and, hence, indirectly influences the semantic meaning. Vice versa, by being processed by data processing code, different input data produce different outcome. Hence, data enforce a particular pragmatic meaning to apply;}
\par\plain {\f0\fs24\b0\i0   \\item The software agent cannot properly accomplish its role as semantic vehicle when the reciprocity between the data and how to process them is disturbed, viz. apply different background knowledge.  }
\par\plain {\f0\fs24\b0\i0 \\end\{enumerate\}}
\par\plain {\f0\fs24\b0\i0 \\textbf\{Implications:\}}
\par\plain {\f0\fs24\b0\i0 \\begin\{enumerate\}}
\par\plain {\f0\fs24\b0\i0   \\item Maintaining, under all circumstances, a valid reciprocity between data and data processing is a necessary prerequisite for an agent to properly act as semantic vehicle;}
\par\plain {\f0\fs24\b0\i0   \\item A software agent reflects semantics by its particular way of operating on the data.}
\par\plain {\f0\fs24\b0\i0 \\end\{enumerate\}  }
\par\plain {\f0\fs24\b0\i0 \\end\{mmdp\}}
\par\pard\plain \ri-11066\ql\ltrch\loch \f0\fs24\b0\i0
\par\pard\plain \ltrch\loch {\f0\fs24\b0\i0 On applying the principle of high cohesion in this semantic reading, pairs of data and data processing code emerge that show high coherence while maintaining low or no coupling with other pairs. Whenever the data in such a pair refer to the state of affairs in the DoA, that pair implements}{\f0\fs24\b0\i0  a strict coupling between the semantic meaning and the pragmatic meaning. Clearly, such pairs reflect the semantic vehicles of a software agent. Consequently, their semantically valid reciprocity is essential to the capability of the software agent to act as semantic vehicle. We reflect the effect of applying the principle of high cohesion with the following definition.  }
\par\plain \f0\fs24\b0\i0
\par\pard\plain \ql\ltrch\loch {\f0\fs24\b0\i0 \\begin\{mmdef\}[Atomic semantic monolith]\\label\{def:atomic-semantic-monolith\}}
\par\plain {\f0\fs24\b0\i0 An Atomic Semantic Monolith (ASM) encapsulates a pair of tokens, $\\pair\{\\token\{T\}_d; \\token\{T\}_p\}$, that constitutes the valid reciprocity between data and software code as a reduced form of semantics, where:}
\par\plain {\f0\fs24\b0\i0 \\begin\{itemize\}}
\par\plain {\f0\fs24\b0\i0   \\item $\\token\{T\}_d$, the data token, carries the \\emph\{semantic\} meaning;}
\par\plain {\f0\fs24\b0\i0   \\item $\\token\{T\}_p$, the data processing token, carries the \\emph\{pragmatic\} meaning. }
\par\plain {\f0\fs24\b0\i0 \\end\{itemize\}}
\par\pard\plain \ri-16946\ql\ltrch\loch {\f0\fs24\b0\i0 \\emph\{Valid reciprocity\} denotes the degree with which the collective outcome of processing all potential data tokens by the process token refers to the intended states of affairs in reality. \\emph\{Monolithic\} refers to the non-dividable whole of $\\pair\{\\token\{T\}_d; \\token\{T\}_p\}$  }
\par\pard\plain \ql\ltrch\loch {\f0\fs24\b0\i0 \\end\{mmdef\}}
\par\plain \f0\fs24\b0\i0
\par\plain {\f0\fs24\b0\i0 A few words}{\f0\fs24\b0\i0  on the contents of both tokens. In order for the data token to carry the semantic meaning, it can specify concepts, their taxonomy including logical relations such as completeness and disjointness, ontological relations between them, or values and the types of value that apply. In doing so, it provides the representation of all germane entities, including their structure and interrelations, in the DoA and the means to validate any statement that can be made about it. In order for the data processing token to carry the pragmatic meaning, it can specify all logical, physical or business rules that are used to draw conclusions from individual facts, as well as constraints that should apply when executing those rules. In doing so it determines the consequences of stated premises and completes the particular state of affairs that applies in the DoA. Together, they not only *specify* the representation and determination of the state of affairs, they also *represent* the actual state of affairs, turning the data set into a reflection of the domain of application.     }
\par\plain \f0\fs24\b0\i0
\par\plain {\f0\fs24\b0\i0 What is meant with atomicity and how to enforce such is explained in the next section.}
\par\pard\plain \ltrch\loch \f0\fs24\b0\i0
\par\pard\plain \ql\ltrch\loch {\f0\fs24\b0\i0 <!-- page additions -->}
\par\pard\plain \ri-10760\ql\ltrch\loch {\f0\fs24\b0\i0 [def:softmodelsreal]: src\\images\\SoftwareModelsReality.png \{#fig:software-models-reality\}}
\par\plain \f0\fs24\b0\i0}