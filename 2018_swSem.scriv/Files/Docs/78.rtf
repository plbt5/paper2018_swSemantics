{\rtf1\ansi\ansicpg1252\uc1\deff0
{\fonttbl{\f0\fmodern\fcharset0\fprq2 CourierNewPSMT;}{\f1\fmodern\fcharset0\fprq2 CourierNewPS-ItalicMT;}}
{\colortbl;\red0\green0\blue0;\red255\green255\blue255;}
\paperw12240\paperh15840\margl1800\margr1800\margt1440\margb1440\fet2\ftnbj\aenddoc
\pgnrestart\pgnstarts0
\pard\plain \ltrch\loch {\f0\fs24\b0\i0 We take the position that software essentially represents a token-based machine without the ability to close the gap between token and reality. This }{\f1\fs24\b0\i1 Grounding Problem}{\f0\fs24\b0\i0  [@Harnad1990], a fundamental issue in software engineering about semantics, is hardly addressed [@Steels:2008tr], if at all [@Cregan2007]. This implies that the semiotic triangle is denied its conceptualisation vertex, and the sign remains incomplete. This is confirmed by the software engineering discipline, since it consistently speaks of \loch\af0\hich\af0\dbch\af0\uc1\u8216\'91models that represent reality\u8217\'92 in a certain purposeful context }{\f1\fs24\b0\i1 without}{\f0\fs24\b0\i0  factoring the conceptualisation into the equation [@A\loch\af0\hich\af0\dbch\af0\uc1\u223\'DFmann2006]. The first consequence is that the edges about abstraction and subjectivation remain vague or necessarily conflate on the relationship between the model and reality, depicted in \\cref\{fig:software-models-reality\}. The next consequence is that the sign becomes \u8220\'93beheaded\u8221\'94, cutting-off our \u8220\'93knowledge about our given remark or doctrine\u8221\'94 [@Quine:1953er], making it impossible to perform semeiosis anymore. Yet, we make do with weak AI and therefore with this beheaded sign necessarily, and must conclude that genuine semantics can not ever exist in current software agents.  }
\par\plain \f0\fs24\b0\i0
\par\pard\plain \ri-16872\ql\ltrch\loch {\f0\fs24\b0\i0 ![Software engineering applies a beheaded semiotic triangle in which its edges remain vague or conflate in the single relation between model and reality.][def:softmodelsreal]}
\par\plain \f0\fs24\b0\i0
\par\pard\plain \ql\ltrch\loch {\f0\fs24\b0\i0 Using current software, semantics exist only by grace of the software engineer (at the modelling level) and the end user (during operations). The end user at the human-machine interface performs the semeiosis by interpreting the tokens that are displayed (}{\f1\fs24\b0\i1 subjectivation}{\f0\fs24\b0\i0 ). Developing current software, the human software engineer performs the semeiosis and all models are }{\f1\fs24\b0\i1 representations}{\f0\fs24\b0\i0  of this engineer\loch\af0\hich\af0\dbch\af0\uc1\u8217\'92s conceptualisations. We will focus on two of the typically generated models, the paired models that constitute the engineers' semantics: the }{\field{\*\fldinst HYPERLINK "scrivcmt://B276A47B-7D35-4DC8-8ADD-2D643EBF17E3"}{\fldrslt\f0\fs24\b0\i0 information or data models}}{\f0\fs24\b0\i0  that refer to the *information entities* in reality, paired with the }{\field{\*\fldinst HYPERLINK "scrivcmt://24C23001-8220-4669-AFED-3DA3C49B76E4"}{\fldrslt\f0\fs24\b0\i0 process or business models}}{\f0\fs24\b0\i0  that represent the *process entities* that operate on the information entities. When the humans has left the building, the capability to verify the semantic coherence between the code and the data is lost. Yet, the reciprocity between data and software code determines the semantic validity of the data processing: the (value of) data influence the behaviour of the software code, whereas the way how the software code acts on the data influences how they refer to reality. For instance, consider a data token $T_d$ with value \\token\{t = 40.3\} to represent temperature, and a data process token $T_p$ to establish fever, e.g., \\token\{t > 37.0\} $\\to$ \\token\{fever\}. The one and only means to keep the software from failing is that both the data and the process (i) are expressed in the same unit of dimension ($\\si\{\\degree\}C$ in this example), apply the same (ii) resolution and (iii) accuracy, to name a few obvious constraints. }
\par\plain \f0\fs24\b0\i0
\par\plain {\f0\fs24\b0\i0 We conclude that whereas semantics can only emerge from software by virtue of the semeiosis by the human-in-the-loop, in the software agent itself semantics are necessarily reduced to the reciprocity between data and software code. We reflect this essential disposition with a definition, which we base on the general agreement in semantic literature [@Grice:1991BT; @Sperber1995] that human communication involves at least a code model and an inference process:  }
\par\plain \f0\fs24\b0\i0
\par\plain {\f0\fs24\b0\i0 \\begin\{mmdef\}[Atomic semantic monolith]\\label\{def:atomic-semantic-monolith\}}
\par\plain {\f0\fs24\b0\i0 An Atomic Semantic Monolith (ASM) denotes a \\emph\{computational\} pair of tokens, $\\pair\{T_d, T_p\}$, that represents the reciprocity between data and software code as a reduced form of semantics. This pair of tokens refers to the intended state of affairs in reality as:}
\par\plain {\f0\fs24\b0\i0 \\begin\{itemize\}}
\par\plain {\f0\fs24\b0\i0   \\item $T_d$, the data token, which carries the \\emph\{semantic\} meaning, or \loch\af0\hich\af0\dbch\af0\uc1\u8220\'93what is said\u8221\'94;}
\par\plain {\f0\fs24\b0\i0   \\item $T_p$, the data processing token, which carries the \\emph\{pragmatic\} meaning, what we like to understand as the comprehension process with its contextual (pragmatic) factors governing disambiguation and reference assignment, viz. \loch\af0\hich\af0\dbch\af0\uc1\u8220\'93to connect with our frame of reference\u8221\'94. }
\par\plain {\f0\fs24\b0\i0 \\end\{itemize\}}
\par\plain {\f0\fs24\b0\i0 Reciprocity denotes the degree with which the collective outcome of processing all potential data tokens by the process token refers to the intended states of affairs in reality. Atomicity refers to the level of granularity at which the entity that is referred to by the data token is considered a non-dividable whole. }
\par\plain {\f0\fs24\b0\i0 \\end\{mmdef\}}
\par\plain \f0\fs24\b0\i0
\par\plain {\f0\fs24\b0\i0 The software agent acts as transport medium for the semantics as it was intended by the software engineer to the semantics as it is experienced by the end user at the human-machine interface. We consider the coherence between data models and data processing models essential for enforcing the software agent to maintain a semantic valid reciprocity between binary code and the data it operates on. How that can be done is explained in the next section.}
\par\plain \f0\fs24\b0\i0
\par\plain {\f0\fs24\b0\i0 <!-- page additions -->}
\par\pard\plain \ri-10760\ql\ltrch\loch {\f0\fs24\b0\i0 [def:softmodelsreal]: src\\images\\SoftwareModelsReality.png \{#fig:software-models-reality\}}}