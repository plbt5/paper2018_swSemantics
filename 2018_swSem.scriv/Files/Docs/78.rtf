{\rtf1\ansi\ansicpg1252\uc1\deff0
{\fonttbl{\f0\fmodern\fcharset0\fprq2 CourierNewPSMT;}{\f1\fmodern\fcharset0\fprq2 CourierNewPS-ItalicMT;}}
{\colortbl;\red0\green0\blue0;\red255\green255\blue255;}
\paperw12240\paperh15840\margl1800\margr1800\margt1440\margb1440\fet2\ftnbj\aenddoc
\pgnrestart\pgnstarts0
\pard\plain \ltrch\loch {\f0\fs24\b0\i0 We take the position that software essentially represents a token-based machine without the ability to close the gap between token and reality. This }{\f1\fs24\b0\i1 Grounding Problem}{\f0\fs24\b0\i0  [@Harnad1990], a fundamental issue in software engineering about semantics, is hardly addressed [@Steels:2008tr], if at all [@Cregan2007]. This implies that in software the semiotic triangle is denied its conceptualisation vertex, and the sign remains incomplete. This is confirmed implicitly by the software engineering discipline, since it consistently speaks of \loch\af0\hich\af0\dbch\af0\uc1\u8216\'91models that represent reality\u8217\'92 in a certain purposeful context }{\f1\fs24\b0\i1 without}{\f0\fs24\b0\i0  factoring the conceptualisation into the equation [@A\loch\af0\hich\af0\dbch\af0\uc1\u223\'DFmann2006]. The first consequence is that the edges about abstraction and subjectivation remain vague and necessarily conflate on the relationship between the model and reality, depicted in \\cref\{fig:software-models-reality\}. The next consequence is that the sign becomes \u8220\'93beheaded\u8221\'94, cutting-off our \u8220\'93knowledge about our given remark or doctrine\u8221\'94 [@Quine:1953er], making it impossible to perform semeiosis anymore. Yet, we make do with weak AI [@Searle:1980hw] and therefore with this beheaded sign necessarily, and must conclude that contemporary software agents can never genuinely perform semiotics.  }
\par\plain \f0\fs24\b0\i0
\par\pard\plain \ri-16872\ql\ltrch\loch {\f0\fs24\b0\i0 ![Software engineering applies a beheaded semiotic triangle in which its edges remain vague or conflate in the single relation between model and reality.][def:softmodelsreal]}
\par\plain \f0\fs24\b0\i0
\par\pard\plain \ql\ltrch\loch {\f0\fs24\b0\i0 Using current software, semantics exist only by grace of the software engineer (at the modelling stage) and the end user (during operations). The end user at the human-machine interface performs the semeiosis by interpreting the tokens that are displayed (}{\f1\fs24\b0\i1 subjectivation}{\f0\fs24\b0\i0 ). In contemporary software development, the human software engineer performs the semeiosis and all models are }{\f1\fs24\b0\i1 representations}{\f0\fs24\b0\i0  of this engineer\loch\af0\hich\af0\dbch\af0\uc1\u8217\'92s conceptualisations. Despite the inability of software to perform semeiosis, the software agent still acts as transport medium for the semantics: from the semantics as it was intended by the software engineer to the semantics as it is experienced by the end user at the human-machine interface, as well as between end-users when collaborating by means of the software agent. The core question then becomes what is required in a software agent to properly accomplish its role as semantic vehicle while it is itself incapable of comprehension. In responding to this question, we consider the many models that populate a software architecture and, following \\cref\{dp:separate-comprehension-from-behaviour\}, look for those that represent semantic meaning and pragmatic meaning. Clearly, the model that carry the semantic meaning is the }{\f0\fs24\b0\i0 Domain Model}{\f0\fs24\b0\i0  since it refers to the germane entities from reality. The pragmatic meaning inheres in the Process Model since it addresses the elements or values from the domain model, process them and arrive at conclusions that are used to direct the process. Despite the agent\loch\af0\hich\af0\dbch\af0\uc1\u8217\'92s inability for semeiosis, the reciprocity between data and software code determines the semantic validity of the agent\u8217\'92s operation: the (values of) data influence the outcome of the software code that operates on them while, vice versa, the way how the software code acts on the data influences how they refer to reality. For instance, consider a data token $T_d$ with value \\token\{t = 40.3\} to represent [|temperature], and a data process token $T_p$ to establish [|fever], e.g., \\token\{t > 37.0\} $\\to$ \\token\{fever\}. The one and only means to keep the software from failing is that both the data and the process apply identical background knowledge, such as the same (i) unit of dimension ($\\si\{\\degree\}C$ in this example), (ii) resolution and (iii) accuracy, to name a few obvious aspects about the value, and (iv) the fact that this particular data token represents a }{\f1\fs24\b0\i1 quality}{\f0\fs24\b0\i0  that inheres on a particular }{\f1\fs24\b0\i1 substance}{\f0\fs24\b0\i0 , and (v) the particular substance being human as opposed to cats (which possess a higher criterion for fever), to name a few obvious ontological aspects. Furthermore, \\token\{fever\} is yet another data token that should be incorporated in the domain model, e.g., a }{\f1\fs24\b0\i1 phase}{\f0\fs24\b0\i0  in the life of a human when the body temperature is above a reference range. Finally, note that because any token is part of a sign that addresses an }{\f1\fs24\b0\i1 entity}{\f0\fs24\b0\i0 , the token itself can be atomic, e.g., a single data element, or a compound, e.g., a complex data model.   }
\par\pard\plain \ql\ltrch\loch \f0\fs24\b0\i0
\par\plain {\f0\fs24\b0\i0 In conclusion, we consolidate the existence of the grounding problem due to inevitable incapability of a software agent to perform semeiosis: Whereas semantics can only emerge from software by virtue of the semeiosis that is performed by the human-in-the-loop, in the software agent itself semantics are necessarily reduced to the reciprocity between data and software code. And since it is an essential characteristic of software to process data, the reciprocity between data and processing code exists inevitably. This results in the following design principle to its effect:}
\par\pard\plain \ri-16946\ltrch\loch \f0\fs24\b0\i0
\par\pard\plain \ri-16946\ql\ltrch\loch {\f0\fs24\b0\i0 \\begin\{mmdp\}[Semantic reciprocity principle]\\label\{dp:reciprocity\}}
\par\plain \f0\fs24\b0\i0
\par\plain {\f0\fs24\b0\i0 In software, semantics reduces to the reciprocity between data and software code.   }
\par\plain {\f0\fs24\b0\i0  }
\par\pard\plain \ri-16946\ltrch\loch {\f0\fs24\b0\i0 \\textbf\{Type of information:\} business  \\\\}
\par\plain {\f0\fs24\b0\i0 \\textbf\{Quality attributes:\} ....   \\\\}
\par\plain {\f0\fs24\b0\i0 \\textbf\{Rationale:\}}
\par\plain {\f0\fs24\b0\i0 \\begin\{enumerate\}}
\par\plain {\f0\fs24\b0\i0   \\item Software essentially represents a token-based machine without the ability to close the gap with entities in reality;}
\par\pard\plain \ri-11066\ql\ltrch\loch {\f0\fs24\b0\i0   \\item We consider the data the vehicle that carries the semantic meaning;}
\par\plain {\f0\fs24\b0\i0   \\item We consider the data processing code the vehicle that carries the pragmatic meaning;}
\par\pard\plain \ri-16946\ltrch\loch {\f0\fs24\b0\i0   \\item By acting on data (tokens), combining them and producing new data (tokens), it is the implicit pragmatic meaning of the software that explicitly changes data and implicitly influences the semantic meaning;}
\par\plain {\f0\fs24\b0\i0   \\ item Software inherently latches onto the reciprocity between data and data processing code and by doing so determines a certain outcome of the subsequent semeiosis of the end user;}
\par\plain {\f0\fs24\b0\i0   \\item The software agent will fail to produce a valid outcome of the semeiosis if the reciprocity between the data and how to process them is broken, viz. apply different background knowledge.  }
\par\plain {\f0\fs24\b0\i0 \\end\{enumerate\}}
\par\plain {\f0\fs24\b0\i0 \\textbf\{Implications:\}}
\par\plain {\f0\fs24\b0\i0 \\begin\{enumerate\}}
\par\plain {\f0\fs24\b0\i0   \\item To get control over both the semantic meaning and the pragmatic meaning as well as over their particular combination is a necessary prerequisite for controlling semantics;}
\par\pard\plain \ri-16946\ql\ltrch\loch {\f0\fs24\b0\i0   \\item Because pragmatic meaning builds on semantic meaning, the former is very sensitive to variations in the latter, deeming a subsequent modification in pragmatic meaning as well. The other way around is less sensitive;}
\par\pard\plain \ri-16946\ltrch\loch {\f0\fs24\b0\i0   \\item A software agent reflects semantics by its particular way of operating on the data.}
\par\plain {\f0\fs24\b0\i0 \\end\{enumerate\}  }
\par\plain {\f0\fs24\b0\i0 \\end\{mmdp\}}
\par\pard\plain \ri-11066\ql\ltrch\loch \f0\fs24\b0\i0
\par\pard\plain \ql\ltrch\loch {\f0\fs24\b0\i0 We consider the coherence between data models and data processing models essential for enforcing the software agent to maintain a semantic valid reciprocity between its binary code and the data it operates on. Such demand translates into a strict coupling between the semantic meaning and the pragmatic meaning, which, on its turn, results necessarily in a monolithic design with respect to semantics. We reflect that consequence with the following definition.  }
\par\plain \f0\fs24\b0\i0
\par\plain {\f0\fs24\b0\i0 \\begin\{mmdef\}[Atomic semantic monolith]\\label\{def:atomic-semantic-monolith\}}
\par\plain {\f0\fs24\b0\i0 An Atomic Semantic Monolith (ASM) encapsulates a pair of tokens, $\\pair\{\\token\{T\}_d, \\token\{T\}_p\}$, that constitutes the valid reciprocity between data and software code as a reduced form of semantics, where:}
\par\plain {\f0\fs24\b0\i0 \\begin\{itemize\}}
\par\plain {\f0\fs24\b0\i0   \\item $\\token\{T\}_d$, the data token, carries the \\emph\{semantic\} meaning;}
\par\plain {\f0\fs24\b0\i0   \\item $\\token\{T\}_p$, the data processing token, carries the \\emph\{pragmatic\} meaning. }
\par\plain {\f0\fs24\b0\i0 \\end\{itemize\}}
\par\plain {\f0\fs24\b0\i0 Valid reciprocity denotes the degree with which the collective outcome of processing all potential data tokens by the process token refers to the intended states of affairs in reality. Atomicity refers to the level of granularity at which the entity that is referred to by the data token is considered a non-dividable whole. }
\par\plain {\f0\fs24\b0\i0 \\end\{mmdef\}}
\par\plain \f0\fs24\b0\i0
\par\plain {\f0\fs24\b0\i0 Indeed, the resulting semantic monolith is not a new phenomenon in software agents. In fact one can consider each and every piece of software, including its data schema, a semantic monolith. In a broader context, a semantic message standard essentially builds a homogeneous semantic meaning to be shared by all participating software agents; the pragmatic meaning is then left as an exercise to the software engineer who is responsible for designing data processing models that effectuate the required valid reciprocity. Nevertheless, a semantic monolith emerges. Such monolith is often regarded with ambivalence: on the one hand it realises a stable groundwork that is necessary for the realisation of agent\loch\af0\hich\af0\dbch\af0\uc1\u8217\'92s abilities on, e.g., semantic interoperability, consistency and reusability; on the other hand, the semantic monolith itself is a consequential byproduct that shows major inflexibility and huge impedance to contextual or behavioural changes, the very reason for abandoning monoliths in software engineering. We defend that an architecture should not accept the emergence of a monolith as a consequence but instead present design choices as to its effectiveness and the potential consequences on the software agent\u8217\'92s -ilities. We consider the size of the semantic monolith an influential parameter in establishing an optimal balance between semantics and monolithic consequences, and therefore address atomicity as an important characteristic, underlined by the }{\field{\*\fldinst HYPERLINK "scrivcmt://E174425A-23BA-4424-AE43-EDADD03CBD86"}{\fldrslt\f0\fs24\b0\i0 following design principle}}{\f0\fs24\b0\i0 .}
\par\plain \f0\fs24\b0\i0
\par\pard\plain \ri-16946\ql\ltrch\loch {\f0\fs24\b0\i0 \\begin\{mmdp\}[Semantic atomicity principle]\\label\{dp:atomicity\}   }
\par\plain \f0\fs24\b0\i0
\par\plain {\f0\fs24\b0\i0 Make the ASM as small as possible, but not smaller than required to express a germane entity. Atomicity refers to the level of granularity at which the (germane) entity that is referred to by the data token is considered a non-dividable whole.}
\par\plain \f0\fs24\b0\i0
\par\pard\plain \ri-16946\ltrch\loch {\f0\fs24\b0\i0 \\textbf\{Type of information:\} business  \\\\}
\par\plain {\f0\fs24\b0\i0 \\textbf\{Quality attributes:\} ....   \\\\}
\par\plain {\f0\fs24\b0\i0 \\textbf\{Rationale:\}}
\par\plain {\f0\fs24\b0\i0 \\begin\{enumerate\}}
\par\plain {\f0\fs24\b0\i0   \\item ...;}
\par\plain {\f0\fs24\b0\i0   \\item ... .  }
\par\plain {\f0\fs24\b0\i0 \\end\{enumerate\}}
\par\plain {\f0\fs24\b0\i0 \\textbf\{Implications:\}}
\par\plain {\f0\fs24\b0\i0 \\begin\{enumerate\}}
\par\plain {\f0\fs24\b0\i0   \\item ...;}
\par\pard\plain \ri-16946\ql\ltrch\loch {\f0\fs24\b0\i0   \\item ... .}
\par\pard\plain \ri-16946\ltrch\loch {\f0\fs24\b0\i0 \\end\{enumerate\}  }
\par\plain {\f0\fs24\b0\i0 \\end\{mmdp\}}
\par\pard\plain \ltrch\loch \f0\fs24\b0\i0
\par\pard\plain \ql\ltrch\loch \f0\fs24\b0\i0
\par\plain {\f0\fs24\b0\i0 A few words on the contents of both models. In order for the data model to carry the semantic meaning, it needs to specify the concepts, their taxonomy including logical relations such as completeness and disjointness, the ontological relations between them, and the values and the types of value that apply. In doing so, it provides the representation of all germane entities, including their structure and interrelations, in the DoA and the means to validate any statement that can be made about it. In order for the data processing model to carry the pragmatic meaning, it needs to specify all logical, physical or business rules that are used to draw conclusions from individual facts, as well as constraints that should apply when executing those rules. In doing so it determines the consequences of a given observation from our domain of application, completing the state of affairs. Together, they not only *specify* the representation and determination of the state of affairs, they also *represent* the actual state of affairs, turning the data into a faithful reflection of the domain of application.     }
\par\plain \f0\fs24\b0\i0
\par\plain {\f0\fs24\b0\i0 What is meant with coherence and how to enforce such is explained in the next section.}
\par\plain \f0\fs24\b0\i0
\par\plain {\f0\fs24\b0\i0 <!-- page additions -->}
\par\pard\plain \ri-10760\ql\ltrch\loch {\f0\fs24\b0\i0 [def:softmodelsreal]: src\\images\\SoftwareModelsReality.png \{#fig:software-models-reality\}}
\par\plain \f0\fs24\b0\i0}