{\rtf1\ansi\ansicpg1252\uc1\deff0
{\fonttbl{\f0\fmodern\fcharset0\fprq2 CourierNewPSMT;}}
{\colortbl;\red0\green0\blue0;\red255\green255\blue255;}
\paperw12240\paperh15840\margl1800\margr1800\margt1440\margb1440\fet2\ftnbj\aenddoc
\pgnrestart\pgnstarts0
\pard\plain \ql\ltrch\loch {\f0\fs24\b0\i0 Similarly to an ontology, a system model, too, requires the formalisation of its language and its grammar. Different to an ontology, a system model lacks a formal interpretation. According to \\cref\{fig:software-models-reality\}, this implies that the conceptualisation node is absent. Therefore, being a model of a system, the entity node now refers to the system under specification (SUS, an existing or planned system all the same [@ObjectManagementGroup2017, sec.6.3.1]), whereas the token node refers to the forward-looking system model. Consider OMG\loch\af0\hich\af0\dbch\af0\uc1\u8217\'92s family of Model Driven Architecture languages [@ObjectManagementGroup2016]. Instead of a formal interpretation, this architecture applies a meta-modelling approach in which a model at a certain layer must comply to the abstract syntax that has been specified at its meta-layer. This has been called \u8220\'93reflection\u8221\'94 [@ObjectManagementGroup2016, section 9]. UML [@ObjectManagementGroup2017;ObjectManagementGroupOMG2005] can be considered the most widely used modelling language applied to represent system models. Its metamodel, the Meta-Object Facility [@ObjectManagementGroup2016], not only specifies both the language and the grammar with which the various UML diagrams can be represented, but also its reflection according to which the diagrams must comply to their metamodels. In this sense the reflection feature replaces the formal languages interpretation function, albeit to reveal the nature of the language constructs in terms of their kinds and features, not their semantics.  }
\par\plain \f0\fs24\b0\i0
\par\plain {\f0\fs24\b0\i0 In conclusion, in order to characterise a system model, we need to characterise its metamodel since without the latter we cannot formulate the compliance of the former. Applying the Meta Object Facility (MOF) in general and the Essential MOF specifically, we will use the EMOF as reference for the metamodel that formulates the expressiveness and our typical characterisation of a system model. EMOF is described as a UML model, hence, its language elements reuse the UML metamodel [@ObjectManagementGroup2017], as follows:}
\par\pard\plain \ltrch\loch \f0\fs24\b0\i0
\par\pard\plain \ql\ltrch\loch {\f0\fs24\b0\i0 \\begin\{mmdef\}[MOF metamodel]\\label\{def:mof-metamodel\}}
\par\pard\plain \tx1899\ql\ltrch\loch {\f0\fs24\b0\i0 The Essential Meta Object Facility language is characterised by an alphabet $\\Sigma = \\tuple\{ C, A, G, O, Pr, Pa, T \}$, where:}
\par\pard\plain \tx1899\ql\ltrch\loch {\f0\fs24\b0\i0 \\begin\{itemize\}[leftmargin=2cm,label=\{\}]}
\par\pard\plain \tx720\ql\ltrch\loch {\f0\fs24\b0\i0   \\item[$C$:]\{denotes a set of classes, which specify a classification of objects together with the features that characterise the structure and behaviour of those objects; a class is a set of instances that share a common notion that sets them apart from other individuals\}}
\par\pard\plain \tx720\ql\ltrch\loch {\f0\fs24\b0\i0   \\item[$A$:]\{denotes a set of association relations, i.e., tuples, whose n-ary instances connect $n \\geq 2$ (not necessarily distinct) classes\}}
\par\pard\plain \tx720\ql\ltrch\loch {\f0\fs24\b0\i0   \\item[$G$:]\{denotes a set of generalization relations, i.e., tuples, whose n-ary instances connect $n-1 \\geq 1$ more specific classes with one more generic, distinct class\}}
\par\pard\plain \tx720\ql\ltrch\loch {\f0\fs24\b0\i0   \\item[$O$:]\{denotes a set of operations, describing possible behaviour of a class that may be directly invoked on instances of that class, potentially modifying values of the object or change states of the system\}}
\par\pard\plain \tx720\ql\ltrch\loch {\f0\fs24\b0\i0   \\item[$Pr$:]\{denotes a set of properties, representing attributes of classes, ends of associations, or parts of mereological classes\}}
\par\pard\plain \tx720\ql\ltrch\loch {\f0\fs24\b0\i0   \\item[$Pa$:]\{denotes a set of parameters, representing typed values that are provided to an operation\}}
\par\pard\plain \tx720\ql\ltrch\loch {\f0\fs24\b0\i0   \\item[$T$:]\{denotes a set of data types whose instances are identified only by their value\}}
\par\pard\plain \tx1899\ql\ltrch\loch {\f0\fs24\b0\i0 \\end\{itemize\}   }
\par\pard\plain \ltrch\loch {\f0\fs24\b0\i0 \\end\{mmdef\}}
\par\plain \f0\fs24\b0\i0
\par\pard\plain \ql\ltrch\loch {\f0\fs24\b0\i0 As opposed to a formal interpretation, the validity of an EMOF language is established by conformance to its metamodel. The EMOF, however, is specified in itself. This so-called reflection mechanism allows to traverse from the model element to its metamodel element which is, again, an EMOF element. Essentially, a model reflection implies an explicit validation against its metamodel that creations, manipulations, finding, changes, and deletions of elements, as well as the relationships between those elements, are as prescribed by their meta-elements. The outcome of the reflection is either True or False, and can only be based on language elements and grammar. The details of reflection can be found in the specifications [@ObjectManagementGroup2016, @ObjectManagementGroup2017, @ObjectManagementGroupOMG2005].}
\par\plain \f0\fs24\b0\i0}