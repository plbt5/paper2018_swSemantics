{\rtf1\ansi\ansicpg1252\uc1\deff0
{\fonttbl{\f0\fmodern\fcharset0\fprq2 CourierNewPSMT;}}
{\colortbl;\red0\green0\blue0;\red255\green255\blue255;}
\paperw12240\paperh15840\margl1800\margr1800\margt1440\margb1440\fet2\ftnbj\aenddoc
\pgnrestart\pgnstarts0
\pard\plain \ri-10760\ltrch\loch {\f0\fs24\b0\i0 Contemporary software architectures apply many models that collectively represent the software agent. We concluded that the conceptual model is a backward-looking (descriptive) model. However, many if not all of the other models that are applied are forward-looking (system) models, prescribing the structure and behaviour of the software agent as such. Indeed, the collective data of the forward-looking (system) models represent the state of the software agent, whereas the collective data of the conceptual model represents the state of affairs in reality. Naturally, the state of affairs impacts the agent\loch\af0\hich\af0\dbch\af0\uc1\u8217\'92s state, and vice versa. What does this mean for the relationship between the system models and the conceptual model? Consider a deployment diagram that couples software processes to hardware components in such a way that extra-functional requirements  such as reliability (fault-tolerance, continuity), performance and throughput, and scalability, are met.  }
\par\pard\plain \ltrch\loch \f0\fs24\b0\i0
\par\pard\plain \ri-10760\ltrch\loch {\f0\fs24\b0\i0\cf1 ![Deployment model for an algorithm that computes heart rate from an ECG signal. The algorithm can be deployed on either the sensor device or the body hub][def:depldiag]}
\par\pard\plain \ri-16872\ltrch\loch \f0\fs24\b0\i0\cf1
\par\pard\plain \ql\ltrch\loch {\f0\fs24\b0\i0 \\Cref\{}{\f0\fs24\b0\i0\cf1 fig:deployment-diagram}{\f0\fs24\b0\i0 \} shows an example of a forward-looking (system) model, depicting two scenarios for deployment of a heart rate detection component. Such diagram does not express any semantics or pragmatics. In stead, the model addresses the balance between performance concerns in relation to continuity and throughput. Deployment (a) requires less throughput than deployment (b) and consumes less power (higher continuity) as well, since Bluetooth communication consumes more power than data processing. Despite the use of the terms \loch\af0\hich\af0\dbch\af0\uc1\u8220\'93ECG\u8221\'94 and \u8220\'93heart rate\u8221\'94, concerns about their meaning, viz. what the tokens refer to in reality, can be completely separated from this diagram and specified in the ASM, since the balance in performance, continuity and throughput does not induce any semantic variations. However, when we consider that deployment (b) could apply a more accurate heart rate detection algorithm because the body hub, e.g., a smart phone, is typically a more powerful device, a completely different situation emerges. Variation in accuracy of data, here the heart rate, has consequences on their pragmatic meaning. For example, medical applications will demand a minimal level of data accuracy. Therefore, the design choice for either deployment (a) or (b) will impact the reciprocity between data and their processing, which violates the \\cref\{dp:semantic-coherence-principle\} as is maintained by the ASM (refer to \\cref\{def:atomic-semantic-monolith\}). As a consequence, it is necessary to introduce the notion on \u8220\'93accuracy\u8221\'94 in the semantic model of the ASM, and include it as guarding constraint to the [|heart rate] concept.    }
\par\pard\plain \ri-10760\ltrch\loch \f0\fs24\b0\i0
\par\plain {\f0\fs24\b0\i0 >>>>> conclusion about the (two different) relationship(s) between the ASM and the deployment diagram, firstly the semantic grounding of the used terms, and secondly, a kind of normal form to abstract semantic variations away by introducing explicit -ilities, viz. building consistency between conceptual model and system model.}
\par\plain \f0\fs24\b0\i0
\par\plain {\f0\fs24\b0\i0 Now consider an activity diagram of an epileptic seizure event detection process, depicted in \\cref\{}{\f0\fs24\b0\i0\cf1 fig:activity-diagram}{\f0\fs24\b0\i0 \}.    }
\par\pard\plain \ltrch\loch \f0\fs24\b0\i0
\par\pard\plain \ri-10760\ltrch\loch {\f0\fs24\b0\i0\cf1 ![An activity diagram, modelling concurrency and synchronisation aspects][def:actdiag]}
\par\pard\plain \ri-16872\ltrch\loch \f0\fs24\b0\i0\cf1
\par\pard\plain \ri-10760\ltrch\loch {\f0\fs24\b0\i0 This activity diagram, too, is a forward-looking (system) model, and expresses how the detection of an epileptic seizure depends on the two concurrent threads delivering convulsion (based on acceleration data) and heart rate events (based on ECG data), the latter with an additional thread timing requirement to remain within one heartbeat. Like the previous deployment diagram, this diagram neither expresses semantics nor pragmatics. Unlike the previous diagram, it does  about ECG or Accuracy, nor the quality of the measurement.  }
\par\pard\plain \ltrch\loch \f0\fs24\b0\i0
\par\plain \f0\fs24\b0\i0
\par\plain {\f0\fs24\b0\i0 ----}
\par\plain {\f0\fs24\b0\i0  }
\par\plain {\f0\fs24\b0\i0 Indeed, by definition of being forward-looking, the models can and will be verified towards their meta-model. Such verification, however, is only in respect to their syntactical formulation. }
\par\plain \f0\fs24\b0\i0
\par\plain \f0\fs24\b0\i0
\par\plain {\f0\fs24\b0\i0 , whereas their meaning should be sought in their relation with the conceptual model. Thus, supporting a semantic verification of the system models demands a clear formal characterisation of the relations with their conceptual model. Furthermore, a similar support of the verification of the coherence within the conceptual model demands a similar formal characterisation of the relations between the semantic model, the pragmatic model, their reference model and the foundational ontology that formulates the ontological commitment. These formal characterisations are the subject of this section. To that end we first present the tooling that we require for these formalisations, viz. formal semantics. The use of mathematics is much more accurate than any other language, and, the mathematical language remains consistent over the different models that we address. Together, this facilitates in tracing the semantic consistency throughout the agent.}
\par\pard\plain \tx720\ql\ltrch\loch \f0\fs24\b0\i0
\par\pard\plain \ltrch\loch {\f0\fs24\b0\i0 We consider a formal language $L$ to be nothing more than a set of strings over an alphabet $\\Sigma$. The grammar of the language, denoted $G$, limits the language to a particular subset of all possible strings over $\\Sigma$, called *theories*, and collectively denoted as $T$. This means that a formal grammar is, essentially, a machine that generates its formal language. Any (composition of) symbol(s) from $\\Sigma$ that violates any of the grammatical rules from $G$ is not part of the language $L$. Together, the grammar and the alphabet create a mathematical structure $\\tuple\{\\Sigma, G\}$, denoted the *abstract syntax* of the language.  }
\par\pard\plain \ri-8561\ltrch\loch \f0\fs24\b0\i0
\par\pard\plain \ri-16872\ql\ltrch\loch {\f0\fs24\b0\i0 When we talk about the semantics of a language $L = \\tuple\{\\Sigma, G\}$, we refer to the truth value that can be assigned to a theory $\\lambda \\in L$ that is generated from grammar $G$ over its alphabet $\\Sigma$. Tarski concluded that the truth value of a theory in a language cannot be defined within that same language [@Tarski:1944wr]. Consequently, a representation always needs to consider two languages, the *object* language that one uses to communicate theories, and its higher order *metalanguage* that is used to talk about the truth of theories from the object language. To determine the truth value of a theory, two constructs are required. Firstly, the *interpretation* function can make the transition from the language domain to the metalanguage domain. This function, denoted $\\intn$, will take a theory $\\lambda$ as argument and produces a construct in the metalanguage. In formal semantics, several metalanguages can apply, e.g., petri-nets, but the metalanguage that is usually applied in literature for information modelling is set theory, which we use here as well. Hence, $\\intn : \\Sigma \\to \\EuScript\{D\} \\cup \\EuScript\{R\}$. Here, $\\EuScript\{D\} \\cup \\EuScript\{R\}$ specifies the DoI in set theory by specifying (i) the individuals of interest, denoted $\\EuScript\{D\}$, and (ii) the relations of interest, $\\EuScript\{R\}$. The latter specify those parts of the DoI that are characterised by a number of elements that play a part in the relation, viz. their arity. Relations are used to refer to categories, e.g., the individuals from a subset that are cars (a unary relation), or the marriage between two individuals (a binary relation), or the relation between particular marriages and the individual who closed those marriages (another binary relation), or the class of 1999 (where $n$-ary equals the number of students passing the exams). In other words, any well-formed formula of the language can be extended in set theory. Following the *principle of semantic compositionality*, the interpretation function assigns for every constant symbol in $\\Sigma$ that occurs in $\\lambda$, zero, one or more element(s) in $\\EuScript\{D\}$, and for every $n$-ary predicate symbol in $\\Sigma$ that occurs in $\\lambda$, one or more $n$-ary relation(s) in $\\EuScript\{R\}$, and for every connector that represent operators used by the grammar of the language, e.q., a logical AND, to a set operation, e.g., here conjunction. Note that the definition does not enforce $\\intn(\\cdot)$ to be surjective on $\\EuScript\{D\} \\cup \\EuScript\{R\}$; in fact, it allows for being non-injective as well (elements from $\\EuScript\{D\} \\cup \\EuScript\{R\}$ can be assigned more than one token).}
\par\plain {\f0\fs24\b0\i0 Secondly, a *valuation* function is required, denoted $\\Phi$, which establishes the truth of a metalanguage construct. This is a rather simple function since it only needs to establish whether the individuals and relations that are part of the construct are indeed present in the DoI, $\\EuScript\{D\} \\cup \\EuScript\{R\}$, as suggested by the construct. For instance, if the construct suggests that an individual, e.g., that particular thing of mine that has got four wheels, belongs to a particular subset, e.g., the set of cars, then the valuation function checks whether $c$, representing the subject individual, is part of $C$, representing the subset of cars: $\\Phi(c \\in C) = \\concept\{T\}$ iff $c \\in C$ and $\\concept\{F\}$ otherwise. Note that the valuation function is often deemed implicitly by the interpretation function: $\\intn : L \\to \\EuScript\{D\} \\cup \\EuScript\{R\} \\cup \\domB$.   }
\par\plain \f0\fs24\b0\i0
\par\pard\plain \ltrch\loch \f0\fs24\b0\i0
\par\plain {\f0\fs24\b0\i0\cf1 <!-- page additions -->}
\par\pard\plain \ri-10760\ql\ltrch\loch \f0\fs24\b0\i0\cf1
\par\pard\plain \ri-10760\ltrch\loch {\f0\fs24\b0\i0\cf1 [def:depldiag]: src\\images\\DeploymentDiagram.png \{#fig:deployment-diagram width=90%\}}
\par\plain {\f0\fs24\b0\i0\cf1 [def:actdiag]: src\\images\\ActivityDiagram.png \{#fig:activity-diagram width=90%\}}}