{\rtf1\ansi\ansicpg1252\uc1\deff0
{\fonttbl{\f0\fmodern\fcharset0\fprq2 CourierNewPSMT;}}
{\colortbl;\red0\green0\blue0;\red255\green255\blue255;}
\paperw12240\paperh15840\margl1800\margr1800\margt1440\margb1440\fet2\ftnbj\aenddoc
\pgnrestart\pgnstarts0
\pard\plain \ltrch\loch {\f0\fs24 Semantics are often denoted as the understanding of the data. Despite the often used terms *smart* or *intelligent*, e.g., smart watches, or intelligent autonomous systems, computers are inherently stupid. The notion of understanding is completely alien to them. In fact, it is the IT engineer who performs the understanding of data upfront, and implements the proper response to such understanding in program code. \line \line }
\par\plain {\f0\fs24 To get a better grip on the meaning of semantics and semantic interoperability, we address first what signifies semantics before addressing semantic interoperability. For that, we use the tools that are provided by the discipline of semiotics, which denotes the study of signs, reality and meaning.\line \line }
\par\plain {\f0\fs24 In response to earlier distributed demands, the software engineering discipline introduced the component-based development paradigm, subsequently followed by the service-oriented composition paradigm and the contemporary micro-service architectures. Although compositions and (micro-)services replace monolithic applications and enable distributed use, each contemporary software agent still implements a monolith, albeit a semantic one. This can be explained in terms of the semiotic[^1] sign, depicted in Figure 1, as follows. Data, be them numerical values, text strings, identifiers or even pictures and images, are to be considered as *signifiers* only, i.e., tokens *representing* what is signified in the real world.}}