{\rtf1\ansi\ansicpg1252\uc1\deff0
{\fonttbl{\f0\fmodern\fcharset0\fprq2 CourierNewPSMT;}{\f1\fmodern\fcharset0\fprq2 CourierNewPS-ItalicMT;}}
{\colortbl;\red0\green0\blue0;\red255\green255\blue255;}
\paperw12240\paperh15840\margl1800\margr1800\margt1440\margb1440\fet2\ftnbj\aenddoc
\pgnrestart\pgnstarts0
\pard\plain \ltrch\loch {\f0\fs24\b0\i0 Semantics in software is defined explicitly, e.g., by local information models or data schemata, or as semantic standard in a more collaborative context. When specifying semantics extensive use is made of natural language or informal models such as UML class diagrams, resulting in a domain model the concepts of which recur in process models. These models are subsequently transformed, manually or with some form of automation, into program code. This can be considered the mainstream approach towards semantics in software, which introduces two fundamental issues that harm the business. Firstly, this approach makes that semantics becomes scattered over and coagulated in the software code as implicit implementation [@Osterweil2019]: either as activities or processes from process models that transform its input data into its output data, or as entities - possibly decomposed into sub-entities - that originate from the information model and are generated by processes as their output data or used by activities as their input data. Implicit semantics as scattered, coagulated software code is difficult to manage, let alone to maintain and reuse it without introducing high costs or long lead times. Secondly, software can only operate on a token-based machine whereas semantics require an interpretation outside the realm of tokens. This fundamental incompatibility drives us to the conclusion that semantics cannot exist in software. At best, software acts as vehicle with semantic cargo to be delivered to a human actor who is capable turn the cargo into semantics. The better the software can perform this task, the more effective the software will show. Unfortunately, software is not a transport medium only; it is designed to alter its data in response to events that occur in the application domain. Consequently, on its way towards the user the vehicle is required to operate on its cargo and change its semantics to represent a different state of affairs than it originally started with. Whenever the cargo is operated on, it must be assured that the resulting semantics remains faithful to reality. Due to the incompatibility between software and semantics, this assurance can not be validated by the software itself. As a consequence, each and every operation that is applied on the cargo must be foreseen, and, validated in design upfront. }
\par\plain \f0\fs24\b0\i0
\par\plain {\f0\fs24\b0\i0 Our observation is that both issues have something in common: Wherever data are involved their software semantics denotes a snippet of program code that in the end refers to some state of affairs in reality. Now consider a piece of software that addresses some business concern, denoted in the remainder of this paper by a *software agent*, and assume that we are capable to abstract the software semantics into a single distinct, tangible and computational artifact as opposed to the above scattered and solidified, tacit and implicit implementation. Assume further that this semantic artifact is capable to maintain, under all circumstances within defined boundaries, the faithfulness to reality about everything that the software agent needs to know about reality. Then: a }{\f1\fs24\b0\i1 tangible}{\f0\fs24\b0\i0  semantic artifact enables the capability for other software components to explicitly connect to the state of affairs in the domain of application; a }{\f1\fs24\b0\i1 single distinct}{\f0\fs24\b0\i0  semantic artifact encapsulates all semantic concerns into one view or component of the software agent; a }{\f1\fs24\b0\i1 computational}{\f0\fs24\b0\i0  artifact allows to reason over the state of affairs and derives the consequences of adding, modifying or removing facts from it. Apart from a more concrete scope and definition on what is meant with the term }{\f1\fs24\b0\i1 software semantics}{\f0\fs24\b0\i0 , this would gain three paramount improvements over the current situation: Firstly, by encapsulating semantics into a distinct component we gather all snippets of code that refer to state of affairs in reality in one place. This enables reuse, maintainability, evolution and extensibility, and many other -ilities that we deem relevant to consider when engineering semantics. Furthermore, and like any other software component, by making actual use of these -ilities, e.g., reuse, maintainability, evolution and extensibility, the quality of the component will improve as well, viz. its faithfulness to reality. Secondly, as opposed to documenting semantics, its computational characteristic allows the use of restrictions, rules and axioms in order to make domain assumptions explicit, which maintains the consistency of the data set with them. In other words, each snippet of code can only operate within predefined boundaries and have its validity designed upfront. Thirdly, from a business perspective, considering semantics a distinct component dramatically improves its economic value by (i) significantly extending its life-cycle,(ii) extending its application to more than one software agent, and (iii) providing a consistent semantic foundation that reduces hidden ambiguities or semantic contradictions over the full enterprise application landscape and the external business value network alike.    }
\par\plain \f0\fs24\b0\i0
\par\plain {\f0\fs24\b0\i0 The main idea of this paper is to consider software semantics to stand for the reciprocity between data and the data processing code of software, and to encapsulate this reciprocity into a single semantic component that addresses the above demands: consolidating faithfulness to reality under the full operational scope; an explicit specification of semantics that is computational by necessity; and allowing the application of quality parameters when engineering semantics. Following this idea results in our contribution to the consolidation of semantics in contemporary architectures, viz. three architectural concerns on semantics that apply necessarily, including their architectural principles about semantics to guide their resolution, and an additional ISO42010 Viewpoint and View, as follows:     }
\par\plain \f0\fs24\b0\i0
\par\plain {\f0\fs24\b0\i0 * }{\f1\fs24\b0\i1 Semiotic and pragmatic concerns}{\f0\fs24\b0\i0 : Based on the disciplines of semiotics and pragmatics, we explain why semantics cannot exist in software and why we should focus on the reciprocity between data and the data processing code of software instead. Based on this we can explain the limits of semantics in the realm of software, show the emergence of a semantic monolith, and derive their architectural consequences for software semantics (\\cref\{semiotic-and-pragmatic-concerns\});}
\par\plain {\f0\fs24\b0\i0 * }{\f1\fs24\b0\i1 Domain appropriateness concerns}{\f0\fs24\b0\i0 : Representing semantics will result in a model. Based on formal semantics, modelling and modelling languages, we argue that the application of ontologies and ontological commitment are fundamental to represent reality faithfully in a model (\\cref\{domain-appropriateness-concerns\});}
\par\plain {\f0\fs24\b0\i0 * A}{\f1\fs24\b0\i1 rchitectural consistency concerns}{\f0\fs24\b0\i0 : No matter how accurately reality has been modelled, without its valid integration in the architecture, semantics cannot be applied in order to direct the functionality, scope and validity of the other architectural models. We show how semantics can be related to the system models in a consistent and valid way (\\cref\{architectural-consistency\});}
\par\plain {\f0\fs24\b0\i0 * }{\f1\fs24\b0\i1 ISO42010 Architecture Viewpoint}{\f0\fs24\b0\i0 : We verify the applicability of the above concerns and principles by formulating their architectural consequences as a specific ISO42010 Semantic Viewpoint, and we show their proper position in the total architecture as corresponding Semantic View. As ISO42010 is considered a set of best practises for describing architectures and being used with architecture frameworks such as MoDAF, TOGAF, DoDAF, RM-ODP and more, we consider this Semantic Viewpoint and View a proper consolidation of semantics for contemporary architectural paradigms (\\cref\{iso42010-viewpoint-on-semantics\}).}
\par\plain \f0\fs24\b0\i0
\par\plain {\f0\fs24\b0\i0 Based on these contributions we defend that software semantics essentially denotes the in software coagulated reciprocity between data and the data processing code. We further defend that one single semantic frame of reference can be used as anchor to ground the semantics of the other architectural models. Furthermore, -ilities such as re-usability, reliability, shareability, portability and interoperability are system engineering benefits that result from separation of concerns, hence the need to separate semantics from the other parts of a software agent. We introduce each of the four subjects above with a short summary of the related foundational theory where appropriate, and will conclude this paper with an overview on related work (\\cref\{related-work\}), and a discussion with suggestions for future work (\\cref\{discussion-future-work\}).}
\par\plain \f0\fs24\b0\i0
\par\plain {\f0\fs24\b0\i0 <!-- Page additions -->}
\par\plain \f0\fs24\b0\i0}