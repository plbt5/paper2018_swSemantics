{\rtf1\ansi\ansicpg1252\uc1\deff0
{\fonttbl{\f0\fmodern\fcharset0\fprq2 CourierNewPSMT;}{\f1\fmodern\fcharset0\fprq2 CourierNewPS-ItalicMT;}}
{\colortbl;\red0\green0\blue0;\red255\green255\blue255;\red229\green255\blue79;}
\paperw12240\paperh15840\margl1800\margr1800\margt1440\margb1440\fet2\ftnbj\aenddoc
\pgnrestart\pgnstarts0
\pard\plain \ltrch\loch {\f0\fs24\b0\i0 Semantics of software are defined explicitly, e.g., by information models, data schemata, or semantic standards. The specification of semantics often makes use of natural language, or of less informal models such as UML class diagrams. Both techniques rely for their accuracy on the expressiveness of the (modeling) language, and for their validity upon human intuition, leaving much room for ambiguities. Still, the specifications are transformed, manually or with some form of automation, into program code. Semantics, then, become scattered over, and coagulated in the software code as implicit implementation[@Osterweil2019], in case of activities or processes as the transformation of its inputs into its outputs, and in case of entities as its generation and use by activities as their input or output, or its hierarchical decomposition into sub-entities.    }
\par\plain \f0\fs24\b0\i0
\par\plain {\f0\fs24\b0\i0 The semantic definition is always considered homogeneous over its use, viz. only one valid interpretation of an activity or an object is allowed.   }
\par\plain \f0\fs24\b0\i0
\par\plain \f0\fs24\b0\i0
\par\plain {\f0\fs24\b0\i0 Abstracting semantics from a tacit, once-only solidified software implementation into a tangible, computational and distinct artifact provides us with the potential to connect to it. Applying semantics as a separate artifact enables its reuse, its maintainability, its evolution and extensibility; all are aspects that influence its quality, viz. its faithfulness to reality, and dramatically improves its economic value by (i) significantly extending its life-cycle and (ii) broadening its application to semantic interoperability over (a) the full enterprise application landscape and (b) the partners in our business value chain. This could imply just another day in the office, because for ICT architects and software engineers, enabling reuse for a valuable component implies to apply the technique of abstraction and to formulate an API and standard for its access and use, such that it can be integrated at the right infrastructural level. After publication of its standard by IEEE, W3C, or through a domain organisation that is to adopt and maintain it, it is ready for reuse. }{\f1\fs24\b0\i1 Quod non est}{\f0\fs24\b0\i0  for semantics, at least not that simple. \loch\af0\hich\af0\dbch\af0\uc1\u8220\'93The successful standardisation of protocols made us believe that we should also }{\f1\fs24\b0\i1 standardise meaning}{\f0\fs24\b0\i0  on the Web. This is a fundamental }{\f1\fs24\b0\i1 misconception}{\f0\fs24\b0\i0 .\loch\af0\hich\af0\dbch\af0\uc1\u8221\'94 [@Janowicz:2013ui]. Because, this is the first time in the history of ICT that its discipline, viz. we - as in the ICT community - are not speaking about a concern that belongs to the realm of information and communication technology: Semantics do not belong to our own realm but to that of the users instead. Consequently, we cannot control it, hence the existence of semantic heterogeneity. Current viewpoints on semantics defy semantic heterogeneity and strive for semantic homogeneity: one single agreed convention on how the syntactic structure of the data or messages shall be semantically interpreted. This brings about many disadvantages: }
\par\plain \f0\fs24\b0\i0
\par\plain {\f0\fs24\b0\i0 * Firstly, the semantic standard is solidified in the technology that carries the data. For a service orientated paradigm this implies that the data schema and the message structure conflate, fixing either the resource part of the API (REST) or the operations part of the API (web services)) }
\par\plain \f0\fs24\b0\i0
\par\plain {\f0\fs24\b0\i0 Additionally, because the current software engineering methods consider semantics homogeneity only, once specified semantics are considered highly stable and every deviation an aberration. Consequently, semantics solidifies in software by implicit operations on data, which brings about a high impedance to its change.}
\par\plain {\f0\fs24\b0\i0   }
\par\plain {\f0\fs24\b0\i0\cb3\highlight3 Disadvatages 2-5 lijken vooral nadeel van standaardisatie te zijn}
\par\plain \f0\fs24\b0\i0
\par\plain {\f0\fs24\b0\i0 Secondly, the costs for establishing a semantic standard are high due to the long lead time for getting agreement on the semantics, to subsequently specify the interfaces and finally implement the standard in their core systems. Practises show that it is difficult for organisations to assure the necessary budgets, partly due to justification of the RoI. And these are just the initial costs, because the world and the way to collaborate change, necessitating the semantic standard to evolve, bringing about additional costs for modifying what was just consolidated. }
\par\plain \f0\fs24\b0\i0
\par\plain {\f0\fs24\b0\i0 Thirdly, the long lead time for a complete cycle implies a huge impedance to change. From idea to a new release of the standard and its subsequent deployment again is counted in months, obstructing business agility already for a single organisation, let alone business chain agility. In an attempt to shorten the lead time standards become contaminated with shortcuts, characterised by a large number of optional elements and many structural duplications only to account for small variations in e.g. values and types, or to produce the superset of all semantic variations that might be encountered. }
\par\plain \f0\fs24\b0\i0
\par\plain {\f0\fs24\b0\i0 This results in the fourth disadvantage of the creation of an overcomplicated, over-designed, fully backwards compatible semantic standard, creating a significant barrier with disproportional investments for new business opportunities and new stakeholders. }
\par\plain \f0\fs24\b0\i0
\par\plain {\f0\fs24\b0\i0 The final disadvantage is the fixed coupling between semantics and technology; new data formats demand other extensions of the standard in order to represent the semantics also in the particular syntax of the subject technology.          }
\par\plain \f0\fs24\b0\i0
\par\plain \f0\fs24\b0\i0
\par\plain \f0\fs24\b0\i0
\par\plain {\f0\fs24\b0\i0 We, the ICT community, should acknowledge that semantics are a representation of some part of the world, viewed from a particular perspective of use. And more importantly, that it is just one particular perspective out of many equally legitimate ones. Some examples are given in \\cref\{tab:perspectives\}.}
\par\plain \f0\fs24\b0\i0
\par\plain {\f0\fs24\b0\i0 -------------------------------------------------------------------------------------------------------------------}
\par\plain {\f0\fs24\b0\i0 Reality to refer to          Perspective #1      Perspective #2       Perspective #3       ...   Perspective #n              }
\par\plain {\f0\fs24\b0\i0 ---------------------------- ------------------- -------------------- ------------------- ------ ------------------}
\par\plain {\f0\fs24\b0\i0 Waves are                    }{\f1\fs24\b0\i1 objects}{\f0\fs24\b0\i0  that        }{\f1\fs24\b0\i1 forces}{\f0\fs24\b0\i0  exerted on    an }{\f1\fs24\b0\i1 accumulation}{\f0\fs24\b0\i0  of   ...   a }{\f1\fs24\b0\i1 relation}
\par\plain {\f0\fs24\b0\i0                              I can point at      dikes, walls or      other waves }{\f1\fs24\b0\i1               }{\f0\fs24\b0\i0  between water,}
\par\plain {\f0\fs24\b0\i0                                                  oil rigs                                        current, wind and}
\par\plain {\f0\fs24\b0\i0                                                                                                  the seabed}
\par\plain \f0\fs24\b0\i0
\par\plain {\f0\fs24\b0\i0 $\\;$}
\par\plain \f0\fs24\b0\i0
\par\plain {\f0\fs24\b0\i0 How many terrorist attacks   1, the number       2, the number        4, the number        ...   2996, the}
\par\plain {\f0\fs24\b0\i0 can be counted on 9/11?      of involved         of collapsed         of involved                number of}
\par\plain {\f0\fs24\b0\i0                              terrorist groups    towers               aircraft                   casualties[^1] }
\par\plain \f0\fs24\b0\i0
\par\plain {\f0\fs24\b0\i0 -------------------------------------------------------------------------------------------------------------------}
\par\plain \f0\fs24\b0\i0
\par\plain {\f0\fs24\b0\i0    : Semantics follow many alternative but equally legitimate points of view on reality, implying that no single one true meaning exists. Hence, semantic heterogeneity is a feature that should be preserved, as opposed to a bug that should be sought to correct. \\label\{tab:perspectives\}}
\par\plain \f0\fs24\b0\i0
\par\plain {\f0\fs24\b0\i0 We defend that software semantics should become explicitly specified }{\f0\fs24\b0\i0\cf1 \loch\af0\hich\af0\dbch\af0\uc1\u8220\'93(...) not in order to know *what there is*, but in order to know what a given remark or doctrine, ours or someone else\u8217\'92s, *says* there is\u8221\'94 [@Quine:1953er].}{\f0\fs24\b0\i0  Since no one single valid perspective exists, one generic standard will not fit all stakeholders. And without a generic applicable standard, no semantic artifact can exist that is sufficiently generic for reuse, and therefore no infrastructural semantic services can emerge. In contemporary architectures, an information model on the *waves* or *terrorist incidents* concepts from \\cref\{tab:perspectives\} deems a definite choice on one of the perspectives, excluding the other legitimate ones. }
\par\plain \f0\fs24\b0\i0
\par\plain {\f0\fs24\b0\i0 The implementation of semantic standards involves considerable expenses, }
\par\plain {\f0\fs24\b0\i0 %presents low sustainability of the implementation, }
\par\plain {\f0\fs24\b0\i0 presents considerable challenges for its maintenance, and creates a significant barrier for new business opportunities. Still, semantic standards remain the current solution pattern to achieve networked business collaboration, a pattern that is applied in and between all application domains. We propose a model driven approach to semantics that standardize a semantic model on the technology independent layer. This provides for flexibility on the data message construction (as opposed to fixed and big message structures), technology-independent API generation (as opposed to a schema-to-schema message structure translations), model-based alignments to couple intra- or inter-domain applications (as opposed to the implementation of data wrappers) and the potential to support both the current message-oriented paradigm and the innovative semantic web paradigm.}
\par\plain \f0\fs24\b0\i0
\par\plain {\f0\fs24\b0\i0 Once semantics become explicit and computational, semantic heterogeneity can become a feature as opposed to a bug (coined by [@Janowicz:2013ui]), leading to higher semantic quality and accuracy, as well as reusability, reliability, shareability, portability and (as we can see in part 2) interoperability of these semantics. }
\par\plain \f0\fs24\b0\i0
\par\plain {\f0\fs24\b0\i0 The main idea of this paper is to standardise semantics at the meta-level as opposed to the semantics themselves. Our contribution to the consolidation of semantics in contemporary architectures are three architectural concerns on semantics that apply necessarily, one set of supporting principles, and an additional ISO42010 Viewpoint and View, as follows:     }
\par\plain \f0\fs24\b0\i0
\par\plain {\f0\fs24\b0\i0 * }{\f1\fs24\b0\i1 Semiotic and pragmatic concerns}{\f0\fs24\b0\i0 : Based on the disciplines of semiotics and pragmatics, we explain why semantics cannot exist in software and why we should focus on the reciprocity between data and the data processing code of software instead. We argument that this reciprocity will always result in a semantic monolith, and that the architecture shall address the size of what should be considered its atomic unity: the larger, the easier to build and maintain; the smaller, the wider its applicability in different contexts (\\cref\{semiotic-and-pragmatic-concerns\});}
\par\plain {\f0\fs24\b0\i0 * }{\f1\fs24\b0\i1 Domain appropriateness concerns}{\f0\fs24\b0\i0 : Representing semantics will result in a model. Based on formal semantics, modelling and modelling languages, we argue that the application of ontologies and ontological commitment are fundamental to represent reality faithfully in a model (\\cref\{domain-appropriateness-concerns\});}
\par\plain {\f0\fs24\b0\i0 * A}{\f1\fs24\b0\i1 rchitectural consistency concerns}{\f0\fs24\b0\i0 : No matter how accurately reality has been modelled, without its valid integration in the architecture, semantics cannot be applied in order to direct the functionality, scope and validity of the other architectural models. We show how semantics can be related to the system models in a consistent and valid way (\\cref\{architectural-consistency\});}
\par\plain {\f0\fs24\b0\i0 * }{\f1\fs24\b0\i1 ISO42010 Architecture Viewpoint}{\f0\fs24\b0\i0 : We verify the applicability of the above concerns and principles by formulating their architectural consequences as a specific ISO42010 Semantic Viewpoint, and we show their proper position in the total architecture as corresponding Semantic View. As ISO42010 is considered a set of best practises for describing architectures and being used with architecture frameworks such as MoDAF, TOGAF, DoDAF, RM-ODP and more, we consider this Semantic Viewpoint and View a proper consolidation of semantics for contemporary architectural paradigms (\\cref\{iso42010-viewpoint-on-semantics\}).}
\par\plain \f0\fs24\b0\i0
\par\plain {\f0\fs24\b0\i0 Based on these contributions we defend that software semantics essentially denote the in software coagulated reciprocity between data and the data processing code. We further defend that one single semantic frame of reference can be used as anchor to ground the semantics of the other architectural models. Furthermore, re-usability, reliability, shareability, portability and interoperability are system engineering benefits that result from separation of concerns, hence the need to separate semantics from the other parts of a software agent. We introduce each of the four subjects above with a short summary of the related foundational theory where appropriate, and will conclude this paper with a discussion on related work (\\cref\{related-work\}) and a discussion, including suggestions for future work (\\cref\{discussion-future-work\}).}
\par\plain \f0\fs24\b0\i0
\par\plain {\f0\fs24\b0\i0 <!-- Page additions -->}
\par\plain \f0\fs24\b0\i0
\par\plain {\f0\fs24\b0\i0 [^1]: as mentioned by Wikipedia, https://en.wikipedia.org/wiki/Casualties_of_the_September_11_attacks, accessed Dec 13, 2018}
\par\plain \f0\fs24\b0\i0
\par\plain \f0\fs24\b0\i0}