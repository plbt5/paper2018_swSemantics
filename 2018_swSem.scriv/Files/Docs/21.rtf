{\rtf1\ansi\ansicpg1252\uc1\deff0
{\fonttbl{\f0\fmodern\fcharset0\fprq2 CourierNewPSMT;}{\f1\fmodern\fcharset0\fprq2 CourierNewPS-ItalicMT;}}
{\colortbl;\red0\green0\blue0;\red255\green255\blue255;}
\paperw12240\paperh15840\margl1800\margr1800\margt1440\margb1440\fet2\ftnbj\aenddoc
\pgnrestart\pgnstarts0
\pard\plain \ltrch\loch {\f0\fs24\b0\i0 When specifying semantics in software, natural language or informal models are used, resulting in a domain model and then process models. These models are transformed into program code. This mainstream approach towards semantics in software introduces two fundamental issues that harm business. Firstly, semantics becomes scattered and coagulated software code [@Osterweil2019]: as activities or processes from process models that transform its input data into its output data, or as (sub)entities from the information model and generated by processes as their output data or used by activities as their input data. This semantics is diffcult to manage, to maintain and to reuse without high costs or long lead times. Secondly, software can only operate on a token-based machine whereas semantics requires an interpretation outside the realm of tokens. This leads to the conclusion that semantics cannot exist in software. At best, software acts as vehicle for semantic cargo to be delivered to a human actor who can turn the cargo into semantics. The better the software performs, the more effective it may be. But software is also designed to alter its data in response to events that occur in the application domain. As vehicle towards the user software it operates on its cargo and changes its semantics to represent a different state of affairs than it started with. And the resulting semantics should remain faithful to reality. Due to the software and semantics incompatibility, the software cannot validity this assurance cannot. Therefore, every operation applied on the cargo must be foreseen and validated in design upfront. }
\par\plain \f0\fs24\b0\i0
\par\plain {\f0\fs24\b0\i0 If we are capable to abstract the software semantics into a not scattered, single distinct, tangible and computational artifact, that is capable to maintain the faithfulness to reality, this tangible semantic artifact enables other software components to explicitly connect to the state of affairs in the domain of application (DoA). Such single distinct semantic artifact encapsulates all semantic concerns into one component of the software agent (a piece of software that addresses some business concern). This computational artifact allows to reason over the state of affairs and to derive consequences of adding, modifying or removing facts from it. With this more concrete scope and definition of software semantics, three paramount improvements over the current over documenting semantics situation are gained. Firstly, all snippets of code referring to state of affairs in reality are in one place by encapsulating semantics into a distinct component. This enables, e.g., reuse, maintainability, evolution and extensibility deemed relevant in considering engineering semantics. Using these enabled possibilities improves also the quality of the component: its faithfulness to reality. Secondly, the consistency of the data set is maintained by the component\loch\af0\hich\af0\dbch\af0\uc1\u8217\'92s computational characteristic allowing the use of restrictions, rules and axioms that enforce explicit domain assumptions. Thirdly, considering semantics a distinct component dramatically improves its economic value by (i) extending its life cycle, (ii) extending its application to more than one software agent, and (iii) providing a consistent semantic foundation reducing hidden ambiguities or semantic contradictions over the full enterprise application landscape and the external business value network.    }
\par\plain \f0\fs24\b0\i0
\par\plain {\f0\fs24\b0\i0 Here, we consider software semantics to stand for the reciprocity between data and data processing, and we encapsulate this reciprocity into a single semantic component Consequently, we consolidate semantics in contemporary architectures by addressing three architectural concerns on semantics that necessarily apply, validated as an ISO42010 Viewpoint and View.     }
\par\plain \f0\fs24\b0\i0
\par\plain {\f0\fs24\b0\i0 * }{\f1\fs24\b0\i1 Semiotic and pragmatic concern}{\f0\fs24\b0\i0 : We explain why semantics cannot exist in software and why we should focus on the reciprocity between data and data processing. Then we explain the limits of semantics in software, show the emergence of a semantic monolith, and derive their architectural consequences for software semantics (\\cref\{semiotic-and-pragmatic-concerns\});}
\par\plain {\f0\fs24\b0\i0 * }{\f1\fs24\b0\i1 Domain appropriateness concern}{\f0\fs24\b0\i0 : Representing semantics will result in a model. Based on formal semantics, modelling and modelling languages, we argue application of ontologies and ontological commitment to be fundamental to represent reality faithfully in a model (\\cref\{domain-appropriateness-concerns\});}
\par\plain {\f0\fs24\b0\i0 * A}{\f1\fs24\b0\i1 rchitectural consistency concern}{\f0\fs24\b0\i0 : Semantics should be integrated in the architecture to direct functionality, scope and validity of the other architectural models. We show how semantics can be related in a consistent and valid way to the system models (\\cref\{architectural-consistency\});}
\par\plain {\f0\fs24\b0\i0 * }{\f1\fs24\b0\i1 ISO42010 Architecture Viewpoint}{\f0\fs24\b0\i0 : We verify applicability of the above by discussing their architectural consequences as a specific ISO42010 Semantic Viewpoint, and their proper position in the total architecture as corresponding Semantic View. We consider this Semantic Viewpoint and View a proper consolidation of semantics for contemporary architectural paradigms (\\cref\{iso42010-viewpoint-on-semantics\}).}
\par\plain \f0\fs24\b0\i0
\par\plain {\f0\fs24\b0\i0 We conclude this paper with an overview on related work (\\cref\{related-work\}), and suggest future work (\\cref\{discussion-future-work\}).}
\par\plain \f0\fs24\b0\i0
\par\plain {\f0\fs24\b0\i0 <!-- Page additions -->}
\par\plain \f0\fs24\b0\i0}