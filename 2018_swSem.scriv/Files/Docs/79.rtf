{\rtf1\ansi\ansicpg1252\uc1\deff0
{\fonttbl{\f0\fmodern\fcharset0\fprq2 CourierNewPSMT;}}
{\colortbl;\red0\green0\blue0;\red255\green255\blue255;}
\paperw12240\paperh15840\margl1800\margr1800\margt1440\margb1440\fet2\ftnbj\aenddoc
\pgnrestart\pgnstarts0
\pard\plain \ri-16872\ql\ltrch\loch {\f0\fs24\b0\i0 Particularly the pragmatic meaning refers to context [@Sperber1995], and we discern two typical contexts. Firstly, the *explicit* context is taken into consideration by the data processing model: those aspects about the data token that are checked, or where variations are allowed to occur, e.g., the different units in which the value can be expressed, or its relationship with another germane entity. Secondly, the *implicit* context, that what is assumed by the data processing but not made explicit, neither as concept to refer to, nor as pragmatic meaning for which a constraint is formulated or validation is being performed. Clearly, semantic conflicts will occur with the latter context where the data processing applies prerequisites that do not fit the true context of the data. Despite the effort of software engineers to minimise the implicit *}{\f0\fs24\b0\i0 incongruous}{\f0\fs24\b0\i0  contexts*, models remain an abstraction of reality and assumptions take the place of the details that are abstracted away. Hence, implicit context can only be minimised, not avoided. Consequently, the validity of the reciprocity between the semantic and pragmatic meaning of an ASM is limited to the scope of the abstractions of both the data and data processing models. Within that particular scope of abstraction, the level of reciprocity, and thus the semantic validity, is directly dependent on the correspondence between the data model and the data processing model. If the data model acknowledges aspects that are not taken into consideration (or recognised) by the data processing model, then the latter model cannot make as much distinction as the former model can provide, resulting in a surjective mapping between reality and the comprehensive capabilities of the semantic monolith. Vice versa, when the data model cannot provide the distinction that the data processing model can assert, some potential outcomes will never be achieved, resulting in an injective mapping between reality and the ASM\loch\af0\hich\af0\dbch\af0\uc1\u8217\'92s comprehensive capabilities. When both situations apply, the mapping between reality and the semantic monolith is neither surjective nor injective, and the software agent will perform rather poor in its role as semantic vehicle from engineer to end user. Contrarily, the semantic monolith is performing optimal when the reciprocity between both models results in a bijective mapping between reality and the semantic monolith: every distinction that one of the models can make, can be addressed by its peer model in the semantic monolith. Note that the optimal situation refers to a minimum cardinality only: one concept in a data model must be used by at least one data processing concept, but nothing prevents more pragmatic meanings to exist for one semantic meaning, and vice versa.   }
\par\pard\plain \ql\ltrch\loch \f0\fs24\b0\i0
\par\plain {\f0\fs24\b0\i0 This leads to the definition of a design principle to its effect; we apply the normative notation from [@Greefhorst2011]):}
\par\pard\plain \ri-8561\ql\ltrch\loch \f0\fs24\b0\i0
\par\plain {\f0\fs24\b0\i0 \\begin\{mmdp\}[Semantic coherence principle]\\label\{dp:semantic-coherence-principle\}}
\par\plain \f0\fs24\b0\i0
\par\pard\plain \ql\ltrch\loch {\f0\fs24\b0\i0 Establish explicit coherence between the models that are contained in a semantic monolith. The coherence of a semantic monolith is directly dependent on the reciprocity between concepts from the data model and concepts from the data processing model. The level of coherence is maximal when each concept from the data model is being addressed by at least one concept from the data processing model, and vice versa.  }
\par\pard\plain \ri-8561\ql\ltrch\loch \f0\fs24\b0\i0
\par\pard\plain \ltrch\loch {\f0\fs24\b0\i0 \\textbf\{Type of information:\} business  \\\\}
\par\plain {\f0\fs24\b0\i0 \\textbf\{Quality attributes:\} (semantic) accuracy, reusability, consistency   \\\\}
\par\plain {\f0\fs24\b0\i0 \\textbf\{Rationale:\}}
\par\plain {\f0\fs24\b0\i0 \\begin\{enumerate\}}
\par\pard\plain \ri-16872\ql\ltrch\loch {\f0\fs24\b0\i0   \\item The software agents must ensure a homomorphic relationship \\footnote\{In mathematics, a relationship $R: D \\to C$ is called a \\emph\{morphism\} if $R$ represents a structure-preserving mapping or function.\} between an atomic semantic monolith and the reality that it refers to;}
\par\plain {\f0\fs24\b0\i0   \\item Semantics in software agents are necessarily reduced to, and emerge from, the reciprocity between the semantic meaning (data models) and the pragmatic meaning (data processing models);  }
\par\pard\plain \ltrch\loch {\f0\fs24\b0\i0   \\item The software agent cannot guarantee to maintain the validity of aforementioned reciprocity without:}
\par\plain {\f0\fs24\b0\i0   \\begin\{enumerate\}}
\par\plain {\f0\fs24\b0\i0     \\item maintaining an explicit reciprocity between the elements of the data model and those of the processing model;}
\par\plain {\f0\fs24\b0\i0     \\item taking measures to maintain such coherence over the full value range of the data;}
\par\plain {\f0\fs24\b0\i0   \\end\{enumerate\}}
\par\pard\plain \ql\ltrch\loch {\f0\fs24\b0\i0   \\item The semantic monolith performs optimal when the coherence can be described as a bijective mapping between reality and a (reciprocal) pair of concepts from the data and the data processing model;}
\par\plain {\f0\fs24\b0\i0   \\item Without maintaining the reciprocity between binary code and the data it operates on, the semeiosis performed by the end user on the result of the data processing and their subsequent semantics cannot be guaranteed to be similar as intended by the software engineer.}
\par\pard\plain \ltrch\loch {\f0\fs24\b0\i0 \\end\{enumerate\}}
\par\plain {\f0\fs24\b0\i0 \\textbf\{Implications:\}}
\par\plain {\f0\fs24\b0\i0 \\begin\{enumerate\}}
\par\plain {\f0\fs24\b0\i0 \\item The coherence principle is a necessary condition for supporting semantics;}
\par\plain {\f0\fs24\b0\i0 \\item Each and every reference to the reality that is made by the software agent can then be made in terms of the data tokens that stem from the ASM;}
\par\plain {\f0\fs24\b0\i0 \\item The scope of semantic validity \\& accuracy is to be addressed explicitly such that it can be referred to. It then facilitates the verification that the scope of the semantic validity \\& accuracy applies in a new context as well;}
\par\plain {\f0\fs24\b0\i0 \\item Reuse of data or data processing, implies reuse of the ASM. The granularity of the reuse is therefore directed by the atomicity of the ASM. Having established explicit coherence improves the quality of data and code reuse;}
\par\plain {\f0\fs24\b0\i0 \\item An ASM provides by its nature for a consistent and particular perspective on reality.}
\par\plain {\f0\fs24\b0\i0 \\end\{enumerate\}  }
\par\plain {\f0\fs24\b0\i0 \\end\{mmdp\}}
\par\pard\plain \ri-16872\ql\ltrch\loch \f0\fs24\b0\i0
\par\plain {\f0\fs24\b0\i0 Coherence between models can be established with use of a single unique reference against which the truth of the expressions of both models can be verified. In semiotics, this single unique reference is considered reality, as indicated in \\cref\{fig:semiotic-triangles\}(b) by the *trueness* characteristic. Except as toy example in [@Steels:2008tr], this is clearly not possible. The *correctness* characteristic is the only alternative left, taking the conceptualisation node as its principle point of reference, as depicted in \\cref\{fig:single-semantic-reference\}(b). This is exactly what the mathematical branch of *formal semantics* achieves [@Gamut1991; @Genesereth:1987dg] with its three main characteristics, depicted in \\cref\{fig:single-semantic-reference\}(a), viz. connecting (i) an abstract syntax of a language to (ii) a Domain of Interpretation (DoI, usually a set theoretic framework) by defining (iii) an interpretation function from the abstract syntax onto the set theoretic framework. In terms of the semiotic triangle, \\cref\{fig:semiotic-triangles\}(b), this implies the following:}
\par\plain \f0\fs24\b0\i0
\par\plain {\f0\fs24\b0\i0 (i) a semantic monolith is formulated as two *representation* nodes, each node formulated by use of an abstract syntax (and grammar) as its modelling language. In this reading, a model is a particular constellation of tokens;}
\par\plain {\f0\fs24\b0\i0 (ii) a particular *conceptualisation* is a mathematical formulation as a DoI, viz. specific constellation of (unnamed) individuals, sets of individuals, and sets of sets; }
\par\plain {\f0\fs24\b0\i0 (iii) each *subjectivation* edge is formulated as interpretation function that assigns a mapping from modelling language tokens onto the set elements, enabling the evaluation of a specific model against the intended conceptualisation from (i). }
\par\plain \f0\fs24\b0\i0
\par\plain {\f0\fs24\b0\i0 In this way, the cognitive quality of the conceptualisation can be substituted with a set theoretic mathematical framework. Formulating the conceptualisation as a set theoretic model essentially remains a representation, albeit a mathematical one. One can argue that such substitution does not resolve the grounding problem, and appropriately so. Still, mathematics provide for a very exact way to express oneself, reducing the ambiguity that comes implicitly with any other language, and such mathematical constructs come as close to the conceptualisation as we possibly can get with a token-based machine. Furthermore, logical constructs used at the syntactical level can be interpreted into set theoretic operations, facilitating the evaluation of (complicated) expressions. Formal semantics thus provides a single DoI about a particular conceptualisation as principle point of reference for both the data model and the data processing model. The particular conceptualisation is then replaced with a particular DoI, and both subjectivation relations are replaced with their interpretation function for the abstract syntax of the models on that DoI. This has been depicted in \\cref\{fig:single-semantic-reference\}.}
\par\pard\plain \ltrch\loch \f0\fs24\b0\i0
\par\pard\plain \ri-16872\ql\ltrch\loch {\f0\fs24\b0\i0 ![Maintaining the reciprocity between data ($T_d$) and data processing models ($T_p$) through a single semantic reference, viz. the conceptualisation (b), represented as DoI, viz. a selection of germane entities with domain specific characteristics defined as sets (a).][def:ssref]}
\par\plain \f0\fs24\b0\i0
\par\plain {\f0\fs24\b0\i0 In conclusion, we explain software semantics as the reciprocity between data and software code, realised by maintaining the coherence between pairs of data and data processing models, by applying formal semantics to formulate a particular conceptualisation as the DoI that can act as semantic reference, and interpretation functions which perform the subjectivation from the data and operation models to that reference.}
\par\pard\plain \ltrch\loch \f0\fs24\b0\i0
\par\pard\plain \ql\ltrch\loch {\f0\fs24\b0\i0 The notion on semantic coherence can be seen in object-orientation (OO) as well, where the class can be seen as a construct similar to a semantic monolith. Indeed, OO does a very good job at enforcing a reciprocity between data and data operations. However, as a model OO can only provide for an informal \loch\af0\hich\af0\dbch\af0\uc1\u8220\'93representation\u8221\'94 relation with reality as depicted in \\cref\{fig:software-models-reality\} due to the absence of a formal underlying framework and, henceforth, absence of a formal DoI. As we will see in \\cref\{explicit-semantics\}, OO makes a good instrument for maintaining coherence, but cannot represent semantics explicitly. }
\par\pard\plain \ri-16872\ql\ltrch\loch \f0\fs24\b0\i0
\par\pard\plain \ql\ltrch\loch {\f0\fs24\b0\i0 <2nd Principle to be added: Atomicity: Make the ASM as small as possible, but not smaller than required to express a semantic element. Elaborate on the statementmade in the previous section: \loch\af0\hich\af0\dbch\af0\uc1\u8220\'93Atomicity refers to the level of granularity at which the (germane) entity that is referred to by the data token is considered a non-dividable whole.\u8221\'94 >}
\par\pard\plain \ltrch\loch \f0\fs24\b0\i0
\par\plain \f0\fs24\b0\i0
\par\pard\plain \ql\ltrch\loch {\f0\fs24\b0\i0 <!-- page additions -->}
\par\pard\plain \ri-10760\ql\ltrch\loch {\f0\fs24\b0\i0 [def:ssref]: src\\images\\SingleSemanticReference.png \{#fig:single-semantic-reference }{\f0\fs24\b0\i0\cf1 width=90%}{\f0\fs24\b0\i0 \}}
\par\pard\plain \ri-16872\ql\ltrch\loch \f0\fs24\b0\i0}