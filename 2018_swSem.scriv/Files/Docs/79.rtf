{\rtf1\ansi\ansicpg1252\uc1\deff0
{\fonttbl{\f0\fmodern\fcharset0\fprq2 CourierNewPSMT;}{\f1\fmodern\fcharset0\fprq2 CourierNewPS-BoldMT;}}
{\colortbl;\red0\green0\blue0;\red255\green255\blue255;}
\paperw12240\paperh15840\margl1800\margr1800\margt1440\margb1440\fet2\ftnbj\aenddoc
\pgnrestart\pgnstarts0
\pard\plain \ri-16872\ql\ltrch\loch {\f0\fs24\b0\i0 As determined in \\cref\{semiotics-and-pragmatics\}, particularly the pragmatic meaning refers to context [@Sperber1995], and we discern two typical contexts. Firstly, the *explicit* context is taken into consideration by the data processing model: those aspects about the data token that are checked, or where variations are allowed to occur, e.g., the different units in which the value can be expressed, or its relationship with another germane entity. Secondly, the *implicit* context, that what is assumed by the data processing but not made explicit, neither as concept to refer to, nor as pragmatic meaning for which a constraint is formulated or validation is being performed. Clearly, semantic conflicts will occur with the latter context where the data processing applies prerequisites that do not fit the true context of the data. Despite the effort of software engineers to minimise the implicit *incongruous contexts*, models remain an abstraction of reality and assumptions take the place of the details that are abstracted away. Hence, implicit context can only be minimised, not avoided. Consequently, the validity of the reciprocity between the semantic and pragmatic meaning of an ASM is limited to the scope of the abstractions of both the data and data processing models. Within that particular scope of abstraction, the level of reciprocity, and thus the semantic validity, is directly dependent on the coherence between the data model and the data processing model. }
\par\plain \f0\fs24\b0\i0
\par\pard\plain \ql\ltrch\loch {\f0\fs24\b0\i0 This leads to the definition of a design principle to its effect; we apply the normative notation from [@Greefhorst2011]):}
\par\pard\plain \ri-8561\ql\ltrch\loch \f0\fs24\b0\i0
\par\plain {\f0\fs24\b0\i0 \\begin\{mmdp\}[Semantic coherence principle]\\label\{dp:semantic-coherence-principle\}}
\par\plain \f0\fs24\b0\i0
\par\pard\plain \ql\ltrch\loch {\f0\fs24\b0\i0 Establish explicit coherence between the semantic meaning and the pragmatic meaning and separate it in a semantic monolith. The coherence of a semantic monolith is directly dependent on the reciprocity between concepts from the data model and concepts from the data processing model. The level of coherence is maximal when each concept from the data model is being addressed by at least one concept from the data processing model, and vice versa.  }
\par\pard\plain \ri-8561\ql\ltrch\loch \f0\fs24\b0\i0
\par\pard\plain \ltrch\loch {\f0\fs24\b0\i0 \\textbf\{Type of information:\} business  \\\\}
\par\plain {\f0\fs24\b0\i0 \\textbf\{Quality attributes:\} (semantic) accuracy, reusability, consistency   \\\\}
\par\plain {\f0\fs24\b0\i0 \\textbf\{Rationale:\}}
\par\plain {\f0\fs24\b0\i0 \\begin\{enumerate\}}
\par\pard\plain \ri-16872\ql\ltrch\loch {\f0\fs24\b0\i0   \\item The software agents must ensure a homomorphic relationship \\footnote\{In mathematics, a relationship $R: D \\to C$ is called a \\emph\{homomorphism\} if $R$ represents a structure-preserving mapping or function between two algebraic structures of the same type.\} between an atomic semantic monolith and the reality that it refers to;}
\par\plain {\f0\fs24\b0\i0   \\item Semantics in software agents are necessarily reduced to, and emerge from, the reciprocity between the semantic meaning (data models) and the pragmatic meaning (data processing models);  }
\par\pard\plain \ltrch\loch {\f0\fs24\b0\i0   \\item The software agent cannot guarantee to maintain the validity of aforementioned reciprocity without:}
\par\plain {\f0\fs24\b0\i0   \\begin\{enumerate\}}
\par\plain {\f0\fs24\b0\i0     \\item maintaining an explicit reciprocity between the elements of the data model and those of the processing model;}
\par\plain {\f0\fs24\b0\i0     \\item taking measures to maintain such coherence over the full value range of the data;}
\par\plain {\f0\fs24\b0\i0   \\end\{enumerate\}}
\par\pard\plain \ql\ltrch\loch {\f0\fs24\b0\i0   \\item The semantic monolith performs optimal when the coherence can be described as a bijective mapping between reality and a (reciprocal) pair of concepts from the data and the data processing model;}
\par\plain {\f0\fs24\b0\i0   \\item Without maintaining the reciprocity between binary code and the data it operates on, the semeiosis performed by the end user on the result of the data processing and their subsequent semantics cannot be guaranteed to be similar as intended by the software engineer.}
\par\pard\plain \ltrch\loch {\f0\fs24\b0\i0 \\end\{enumerate\}}
\par\plain {\f0\fs24\b0\i0 \\textbf\{Implications:\}}
\par\plain {\f0\fs24\b0\i0 \\begin\{enumerate\}}
\par\plain {\f0\fs24\b0\i0 \\item The coherence principle is a necessary condition for supporting semantics;}
\par\plain {\f0\fs24\b0\i0 \\item Each and every reference to the reality that is made by the software agent can then be made in terms of the data tokens that stem from the ASM;}
\par\plain {\f0\fs24\b0\i0 \\item The scope of semantic validity \\& accuracy is to be addressed explicitly such that it can be referred to. It then facilitates the verification that the scope of the semantic validity \\& accuracy applies in a new context as well;}
\par\plain {\f0\fs24\b0\i0 \\item Reuse of data or data processing, implies reuse of the ASM. The granularity of the reuse is therefore directed by the atomicity of the ASM. Having established explicit coherence improves the quality of data and code reuse;}
\par\plain {\f0\fs24\b0\i0 \\item An ASM provides by its nature for a consistent and particular perspective on reality.}
\par\plain {\f0\fs24\b0\i0 \\end\{enumerate\}  }
\par\plain {\f0\fs24\b0\i0 \\end\{mmdp\}}
\par\pard\plain \ri-16872\ql\ltrch\loch \f0\fs24\b0\i0
\par\plain {\f0\fs24\b0\i0 The definition for *cohere*^[Merriam-Webster dictionary, https://www.merriam-webster.com/dictionary/cohering, accessed Jan 2019] (*intransitive verb, lemma 3*) includes two parts *}{\f1\fs24\b1\i0 (a):}{\f0\fs24\b0\i0  to become united in principles, relationships or interests*, and *}{\f1\fs24\b1\i0 (b):}{\f0\fs24\b0\i0  to be logically or aesthetically consistent*. We consider both parts (a) and (b) relevant to enforce coherence between models. We propose three necessary constructs for enforcing a coherent ASM. Firstly, we understand part (a) as a demand for a *single unique reference* against which the truth of the expressions of both models can be verified. Secondly, we defend that the unification of both models require *one single modelling language* when referring to conceptual elements in order to prevent differences in granularity and accuracy with which principles or relationships are being represented. Thirdly, part (b) is understood as }{\field{\*\fldinst HYPERLINK "scrivcmt://D085128A-3B3E-4002-9ADB-D7EE462B6F47"}{\fldrslt\f0\fs24\b0\i0 *completeness*}}{\f0\fs24\b0\i0  between the elements of the semantic and that of the pragmatic model. We elaborate on the second aspect in \\cref\{ontological-commitment\}, and before addressing the first aspect, we explain the third as follows. }
\par\plain \f0\fs24\b0\i0
\par\plain {\f0\fs24\b0\i0 If the semantic model acknowledges aspects that are not taken into consideration (or recognised) by the pragmatic model (or vice versa), then the latter model cannot make as much distinction as the former model can provide, resulting in a surjective mapping between reality and the comprehensive capabilities of the semantic monolith. For example, when the pragmatic model does not include any rule that addresses the (value of) temperature \\token\{t\}, or, when the semantic model does not include the concept \\token\{fever\} while the rule to establish fever exists in the pragmatic model, then the semantic monolith contains a construct issue since it cannot distinguish between people with and without fever. Whether this issue represents a construct deficiency or construct overload of the ASM depends on whether the distinction is necessary or not, which bears the way to resolve the issue. Nevertheless, the relationship between both models is *incomplete*, and consequently, they are not consistent with each other. The software agent will perform rather poor in its role as semantic vehicle from engineer to end user. In conclusion, a necessary condition for coherence between the semantic and pragmatic model is to enforce a bijective relationship between both models. Then every distinction that one of the models can make, can be addressed or assessed by its peer model.}
\par\plain \f0\fs24\b0\i0
\par\pard\plain \ri-10760\ql\ltrch\loch {\f0\fs24\b0\i0 In semiotics, the single unique reference is considered reality, as indicated in \\cref\{fig:semiotic-triangles\}(b) by the *trueness* characteristic. Except as toy example in [@Steels:2008tr], this is clearly not possible. The *correctness* characteristic is the only alternative left, taking the conceptualisation node as its principle point of reference. This is exactly what the mathematical branch of *formal semantics* achieves [@Gamut1991; @Genesereth:1987dg] with its three main characteristics, }{\field{\*\fldinst HYPERLINK "scrivcmt://B292B9D5-71E4-42D2-97E7-410478F9B4A6"}{\fldrslt\f0\fs24\b0\i0 depicted}}{\f0\fs24\b0\i0  in \\cref\{fig:whatisthecorrectpicture\}, viz. connecting (i) an abstract syntax of a language to (ii) a Domain of Interpretation (DoI), a mathematical framework that implements a formal characterisation of our conceptualisation, by defining (iii) an interpretation function from the abstract syntax onto the formal DoI. We elaborate on the formal characterisation in \\cref\{architectural-consistency\}, however, in terms of the semiotic triangle, \\cref\{fig:semiotic-triangles\}(b), this implies the following:}
\par\pard\plain \ri-16872\ql\ltrch\loch \f0\fs24\b0\i0
\par\plain {\f0\fs24\b0\i0 (i) a semantic monolith is formulated as two *representation* nodes, each node formulated by use of an abstract syntax (and grammar) as its modelling language. In this reading, a model is a particular constellation of tokens that belong to a predefined alphabet (linguistically or graphically alike);}
\par\plain {\f0\fs24\b0\i0 (ii) the single unique reference, denoted the *reference model*, is a mathematical formulation of the DoI, usually a set theoretic framework that specifies a constellation of (unnamed) individuals, sets of individuals, and sets of sets; }
\par\plain {\f0\fs24\b0\i0 (iii) both representation nodes define an interpretation function that assigns a mapping from the tokens in each model onto the (set) elements from the reference model, enabling the evaluation of a specific model against the intended conceptualisation from (i). }
\par\plain \f0\fs24\b0\i0
\par\pard\plain \ri-17053\ql\ltrch\loch {\f0\fs24\b0\i0 In this way, the cognitive quality of the conceptualisation is substituted with a set theoretic mathematical framework. Formulating the conceptualisation as a set theoretic model essentially remains a representation, albeit a mathematical one. One can argue that such substitution does not resolve the grounding problem, and appropriately so. This makes the distinction between our notion on subjectivation between the representation and the cognitive conceptualisation, and the interpretation between the representation model and the model of interpretation, depicted in \\cref\{fig:single-semantic-reference\}(z). Still, mathematics provide for a very exact way to express oneself, reducing the ambiguity that comes implicitly with any other language, and such mathematical constructs come as close to the conceptualisation as we possibly can get with a token-based machine. Formal semantics thus provides the means for a single DoI about a particular conceptualisation as principle point of reference for both the semantic model and the pragmatic model. Together, the latter two models collectively take on the role of the representation of the referenced conceptualisation, and we denote their collective in the remainder of the text as the *conceptual model*. This has been depicted in \\cref\{fig:single-semantic-reference\}.}
\par\pard\plain \ltrch\loch \f0\fs24\b0\i0
\par\pard\plain \ri-16872\ql\ltrch\loch {\f0\fs24\b0\i0 ![The Atomic Semantic Monolith, depicted in terms of the semiotic model (b) and in terms of formal semantics (a). The ASM maintains the reciprocity between data ($T_d$) and data processing models ($T_p$) into a single conceptual model, by identifying a single semantic reference, viz. the conceptualisation that has been represented as DoI.][def:ssref]}
\par\plain \f0\fs24\b0\i0
\par\pard\plain \ri-17053\ql\ltrch\loch {\f0\fs24\b0\i0 In conclusion, we explain software semantics as the reciprocity between data and software code, realised by maintaining the coherence between pairs of data and data processing theories, by (i) applying formal semantics to formulate a particular conceptualisation as the DoI, the reference model, that acts as semantic reference for the interpretation functions from the conceptual model, and by (ii) maintaining a bijective mapping within the conceptual model between the concepts used in the semantic model and those from the pragmatic model, and vice versa. We remain to call the semiotic relationship from representation to conceptualisation one of *subjectivation*, denoted $\\sbjn(\\cdot)$, in order to underline its subjective and human dimension as well as the representational characteristic of the mathematical framework. However, within the ASM, we constrain to the traditional and formal relationship of interpretation between the software representation of the conceptual model and the set theoretic representation of the reference model, denoted $\\intn(\\cdot)$.}
\par\plain \f0\fs24\b0\i0
\par\pard\plain \ql\ltrch\loch {\f0\fs24\b0\i0 <2nd Principle to be added: Atomicity: Make the ASM as small as possible, but not smaller than required to express a semantic element. Elaborate on the statement made in the previous section: \loch\af0\hich\af0\dbch\af0\uc1\u8220\'93Atomicity refers to the level of granularity at which the (germane) entity that is referred to by the data token is considered a non-dividable whole.\u8221\'94 >}
\par\pard\plain \ltrch\loch \f0\fs24\b0\i0
\par\plain \f0\fs24\b0\i0
\par\pard\plain \ql\ltrch\loch {\f0\fs24\b0\i0 <!-- page additions -->}
\par\pard\plain \ri-10760\ql\ltrch\loch {\f0\fs24\b0\i0 [def:ssref]: src\\images\\SingleSemanticReference.png \{#fig:single-semantic-reference }{\f0\fs24\b0\i0\cf1 width=90%}{\f0\fs24\b0\i0 \}}
\par\pard\plain \ri-16872\ql\ltrch\loch \f0\fs24\b0\i0}