{\rtf1\ansi\ansicpg1252\uc1\deff0
{\fonttbl{\f0\fmodern\fcharset0\fprq2 CourierNewPSMT;}}
{\colortbl;\red0\green0\blue0;\red255\green255\blue255;}
\paperw12240\paperh15840\margl1800\margr1800\margt1440\margb1440\fet2\ftnbj\aenddoc
\pgnrestart\pgnstarts0
\pard\plain \ltrch\loch {\f0\fs24 Data, be it numerical values, text strings, identifiers or even pictures and images, are representations of particular state of affairs in reality, expressed by tokens. Data are, thus, signifiers. Hence, the relationship between data (particularly their tokens) and their signified, e.g., a state of affairs in reality, is very real but tacit only. Still, to process data correctly, the application needs to know what the tokens stands for in reality, what is their scope, and what constraints it should apply. The tacit relation between the data tokens and the state of affairs in reality can be considered prior knowledge that is possessed by the application developers, only. And only when that prior knowledge has been applied correctly, it will result in a piece of software code that can process the data correctly, i.e., in accordance to what the data stands for. We, therefore, take the stance that for software systems, semantics should be understood as the very real but tacit relationship that exists between the (tokens representing) the data and the software code that processes that data in a very specific manner. Semantics is like the two sides of a sheet of paper: At the one side it shows the tokens that refer to something in reality, and at the other side it shows that particular piece of the software code that processes that data in accordance to what is considered valid about that particular reality. For instance, [INSERT AN EXAMPLE]. In conclusion, both the software code and the data, despite being separate entities that can stand on their own, are inseparable when establishing semantics. \line There is one more aspect about semantics that we would like to highlight. According to [@Grice:1991BT;@Schulz2007], two sub-types of meaning exist. Firstly, *semantic meaning*, denotes semantics as how the tokens are meant to be interpreted, explained by Grice [@Grice:1991BT] as *"what is said"*: a heart rate reading of `128BPM` refers to a particular state of affairs where a person has been measured the frequency of his/her heart pulse of about 128 beats per minute, rhythmically generated by the sinoatrial node. We consider *semantic meaning* equivalent to our notion on semantics above. Secondly, Grice considers another sub-type that he explains as the *pragmatic meaning*, meaning based on rules governing the use of the semantic meaning. We like to consider this second sub-type as the meaning that emerges from the tokens in the specific context of use, i.e., the meaning that emerges beyond what is said when, e.g., drawing conclusions about the state of affairs. The heart rate reading of `128BPM`, although carried by the very same bits, can carry distinct pragmatic meaning in different domains: as an indication of health in the care domain, and as an indication of performance potential in domains of sports. It is not even necessary to change to another domain, because, when we elaborate on the indication of health, the same bits will refer to very different health conditions in the context of elderly than in the context of new-borns. \line \line }
\par\plain {\f0\fs24 DEFINITION: Semantics in software\line : The semantic meaning that emerges on processing the data, before the software commences with the pragmatic meaning.\line \line }
\par\plain {\f0\fs24 Note that according to our definition, semantics does not imply validity, i.e., being in accordance with the actual state of affairs.}}