{\rtf1\ansi\ansicpg1252\uc1\deff0
{\fonttbl{\f0\fmodern\fcharset0\fprq2 CourierNewPSMT;}}
{\colortbl;\red0\green0\blue0;\red255\green255\blue255;}
\paperw12240\paperh15840\margl1800\margr1800\margt1440\margb1440\fet2\ftnbj\aenddoc
\pgnrestart\pgnstarts0
\pard\plain \ltrch\loch \f0\fs24
\par\plain {\f0\fs24\b0\i0 With the absence of strong AI, only the application that generated the data possesses the know-how to "decode" the data, i.e., to what part of reality the data refer to. Actually, that know-how can be found in the precise way with which the software is designed to work with the particular data. For instance, a statement such as\line `read Patient.tempInC from Sensor_1` \line "encodes" the know-how that the value produced by a sensor (i) refers to the body temperature (ii) of a patient (iii) in degrees Centigrade. As long as `Patient.tempInC` stays within the realm that is aware of that particular know-how, one can safely assume the same know-how will be applied consistently, e.g., in the statement\line `Patient.hasFever = (Patient.tempInC > 38.0)`\line the know-how is applied consistently in the comparison with another value that refers to a critical body temperature in degrees Centigrade, the result of which is subsequently "encoded" as new know-how, here a referral to a particular state of the patient.}
\par\plain \f0\fs24\b0\i0
\par\pard\plain \ri-10862\ltrch\loch {\f0\fs24\b0\i0 ----}
\par\plain \f0\fs24\b0\i0
\par\plain {\f0\fs24\b0\i0 Access-and-play sIOP demands a notion on semantics, often denoted in layman\loch\af0\hich\af0\dbch\af0\uc1\u8217\'92s terms as the \u8220\'93understanding of the data\u8221\'94. Despite the used terms *smart* or *intelligent*, e.g., smart watches, or intelligent autonomous systems, computers are inherently stupid. The notion of understanding is completely alien to them. In fact, it is the IT engineer who performs the understanding of data upfront, and implements the proper response to such understanding in program code. Nevertheless, we do. For instance, when we are asked to explain how we address the grounding problem in the design of our software agent, we can\u8217\'92t; when we are asked to point at the semantics parts in the code of our software agent, we can't. The same question however about, e.g., its scalability, will render a lecture with adequate references to the underlying architecture. We thus remain at a loss of how to engineer semantics into software agents. However, without a clear understanding on semantics and its contribution to the software agent, we are lacking the bridgehead within the software agent that is fundamental to the semantic interoperability bridge. Hence, the first architectural concern to consider is the nature of semantics in software, and we will address that in the next section. }
\par\plain \f0\fs24\b0\i0
\par\plain \f0\fs24\b0\i0
\par\plain \f0\fs24\b0\i0
\par\plain \f0\fs24\b0\i0
\par\plain \f0\fs24\b0\i0
\par\plain {\f0\fs24\b0\i0 ----}
\par\plain \f0\fs24\b0\i0
\par\plain {\f0\fs24\b0\i0 Although technologies such as the Semantic Web and ontologies are available, and despite the principles and practises of the model driven architecture paradigm, no architectural guidance to semantic interoperability exists, neither in terms of architectural principles nor as design practises.}
\par\plain \f0\fs24\b0\i0
\par\plain {\f0\fs24\b0\i0 Given the exponential growth in semantic heterogeneity that follows from distributed use of distributed supplied services over distributed resources, information systems are in a desperate need for a managed semantics, which, similar to the principle to store data only once in order to prevent data conflicts, controls the semantic heterogeneity from a central location in your architecture. Information systems are in a desperate need for an automated sIOP capability to break through this ceiling.}
\par\plain \f0\fs24\b0\i0
\par\plain \f0\fs24\b0\i0
\par\plain \f0\fs24\b0\i0
\par\pard\plain \ltrch\loch \f0\fs24\b0\i0}