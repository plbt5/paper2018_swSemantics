{\rtf1\ansi\ansicpg1252\uc1\deff0
{\fonttbl{\f0\fmodern\fcharset0\fprq2 CourierNewPSMT;}{\f1\fmodern\fcharset0\fprq2 CourierNewPS-ItalicMT;}}
{\colortbl;\red0\green0\blue0;\red255\green255\blue255;}
\paperw12240\paperh15840\margl1800\margr1800\margt1440\margb1440\fet2\ftnbj\aenddoc
\pgnrestart\pgnstarts0
\pard\plain \ltrch\loch {\f0\fs24\b0\i0 We take the position that weak AI is essentially a token-based machine without the ability to close the gap between token and reality. This }{\f1\fs24\b0\i1 Grounding Problem}{\f0\fs24\b0\i0  [@Harnad1990], a fundamental issue in software engineering about semantics, is hardly addressed [@Steels:2008tr], if at all [@Cregan2007]. This implies that the semiotic triangle is denied its conceptualisation vertex, and the sign remains incomplete. This is confirmed by the software engineering discipline, since it consistently speaks of \loch\af0\hich\af0\dbch\af0\uc1\u8216\'91models that represent reality\u8217\'92 in a certain purposeful context }{\f1\fs24\b0\i1 without}{\f0\fs24\b0\i0  factoring the conceptualisation into the equation [@A\loch\af0\hich\af0\dbch\af0\uc1\u223\'DFmann2006]. The first consequence is that the edges about abstraction and subjectivation remain vague or necessarily conflate on the relationship between the model and reality, depicted in \\cref\{fig:software-models-reality\}. The next consequence is that the sign becomes \u8220\'93beheaded\u8221\'94, cutting-off our \u8220\'93knowledge about our given remark or doctrine\u8221\'94 [@Quine:1953er], making it impossible to perform semeiosis anymore. Yet, we make do with weak AI and therefore with this beheaded sign necessarily, and must conclude that genuine semantics can not ever exist in current software agents.  }
\par\plain \f0\fs24\b0\i0
\par\pard\plain \ri-16872\ql\ltrch\loch {\f0\fs24\b0\i0 ![Software engineering applies a beheaded semiotic triangle in which its edges remain vague or conflate in the single relation between model and reality.][def:softmodelsreal]}
\par\plain \f0\fs24\b0\i0
\par\pard\plain \ql\ltrch\loch {\f0\fs24\b0\i0 Using current software, the human end user at the human-machine interface performs the semeiosis by interpreting the tokens that are displayed (subjectivation). Developing current software, the human software engineer performs the semeiosis and all models are representations of this engineer\loch\af0\hich\af0\dbch\af0\uc1\u8217\'92s conceptualisations. We will focus on two of the typically generated models, the paired models that constitute the engineers' semantics: the }{\field{\*\fldinst HYPERLINK "scrivcmt://B276A47B-7D35-4DC8-8ADD-2D643EBF17E3"}{\fldrslt\f0\fs24\b0\i0 information or data models}}{\f0\fs24\b0\i0  that refer to the *information entities* in reality, paired with the }{\field{\*\fldinst HYPERLINK "scrivcmt://24C23001-8220-4669-AFED-3DA3C49B76E4"}{\fldrslt\f0\fs24\b0\i0 process or business models}}{\f0\fs24\b0\i0  that represent the *process entities* that operate on the information entities. These models are just tokens that follow specific language grammars: a representation of its quintessence, viz. a run-time notion on the proper way to operate on the data. Semantics exist only by grace of the designer (at the modelling level) and the end user (during operations). However, when the humans has left the building, the capability to verify the semantic coherence between the code and the data is lost. Yet, the reciprocity between data and software code determines the semantic validity of the data processing: the (value of) data influence the behaviour of the software code, whereas the way how the software code acts on the data influences how they refer to reality. For instance, consider a data token $T_d$ with value \\token\{40.3\} to represent temperature, and a data process token $T_p$ to establish fever, e.g., \\token\{t > 37.0 $\\to$ fever\}. The one and only means to keep the software from failing is that both the data and the process (i) are expressed in the same unit of dimension ($\\si\{\\degree\}C$ in this example), apply the same (ii) resolution and (iii) accuracy, to name a few obvious constraints. We, therefore, take the stance that semantics can only emerge from software by virtue of the semeiosis by the human-in-the-loop, while in the software agent itself semantics are necessarily reduced to the reciprocity between data and software code. Still, the software agent acts as transport medium for the semantics as it was intended by the software engineer to the semantics as it is experienced by the end user at the human-machine interface. We therefore consider the coherence between data models and data processing models essential for enforcing the software agent to maintain a semantic valid reciprocity between binary code and the data it operates on. We reflect this essential disposition with a definition and design principle.  }
\par\plain \f0\fs24\b0\i0
\par\plain {\f0\fs24\b0\i0 \\begin\{mmdef\}[Atomic semantic monolith]\\label\{def:atomic-semantic-monolith\}}
\par\plain {\f0\fs24\b0\i0 An Atomic Semantic Monolith (ASM) denotes a \\emph\{computational\} pair of tokens, $\\pair\{T_d, T_p\}$, that represents the reciprocity between data and software code as a reduced form of semantics, and refers to the intended state of affairs in reality, indicated by \\cite\{Grice:1991BT\} as a twofold:}
\par\plain {\f0\fs24\b0\i0 \\begin\{itemize\}}
\par\plain {\f0\fs24\b0\i0   \\item $T_d$, the data token, which carries the \\emph\{semantic\} meaning, or \loch\af0\hich\af0\dbch\af0\uc1\u8220\'93what is said\u8221\'94;}
\par\plain {\f0\fs24\b0\i0   \\item $T_p$, the process token, which carries the \\emph\{pragmatic\} meaning, what we like to understand as \loch\af0\hich\af0\dbch\af0\uc1\u8220\'93how it relates to our intentions\u8221\'94. }
\par\plain {\f0\fs24\b0\i0 \\end\{itemize\}}
\par\plain {\f0\fs24\b0\i0 Reciprocity denotes the degree with which the collective outcome of processing all potential data tokens by the process token refers to the intended states of affairs in reality. Atomicity refers to the level of granularity of the data token that refers to entities that are considered a non-dividable whole. }
\par\plain {\f0\fs24\b0\i0 \\end\{mmdef\}}
\par\plain \f0\fs24\b0\i0
\par\plain \f0\fs24\b0\i0
\par\plain {\f0\fs24\b0\i0 This leads to the definition of a design principle to its effect; we apply the normative notation from [@Greefhorst2011]):}
\par\pard\plain \ri-8561\ql\ltrch\loch \f0\fs24\b0\i0
\par\plain {\f0\fs24\b0\i0 \\begin\{mmdp\}[Semantic coherence principle]\\label\{dp:semantic-coherence-principle\}}
\par\plain \f0\fs24\b0\i0
\par\pard\plain \ql\ltrch\loch {\f0\fs24\b0\i0 Establish explicit coherence between the models that are contained in a semantic monolith.}
\par\pard\plain \ri-8561\ql\ltrch\loch \f0\fs24\b0\i0
\par\pard\plain \ltrch\loch {\f0\fs24\b0\i0 \\textbf\{Type of information:\} business  \\\\}
\par\plain {\f0\fs24\b0\i0 \\textbf\{Quality attributes:\} (semantic) accuracy, reusability, manageability, understandability   \\\\}
\par\plain {\f0\fs24\b0\i0 \\textbf\{Rationale:\}}
\par\plain {\f0\fs24\b0\i0 \\begin\{enumerate\}}
\par\plain {\f0\fs24\b0\i0   \\item Semantics in software agents are necessarily reduced to, and emerge from, the reciprocity between the data and the software code that operates on them;  }
\par\plain {\f0\fs24\b0\i0   \\item The software agent cannot guarantee to maintain the validity of aforementioned reciprocity without:}
\par\plain {\f0\fs24\b0\i0   \\begin\{enumerate\}}
\par\plain {\f0\fs24\b0\i0     \\item taking measures to maintain the coherence between the data tokens and the processing tokens that operate on them;}
\par\plain {\f0\fs24\b0\i0     \\item taking measures to maintain such coherence over the full value range of the data; }
\par\pard\plain \ri-16872\ql\ltrch\loch {\f0\fs24\b0\i0     \\item assuring the existence of a homomorphic relationship \\footnote\{In mathematics, a relationship $R: D \\to C$ is called a \\emph\{morphism\} if $R$ represents a structure-preserving mapping or function.\} between the semantic monolith and the reality that it refers to;}
\par\pard\plain \ltrch\loch {\f0\fs24\b0\i0   \\end\{enumerate\}}
\par\plain {\f0\fs24\b0\i0   \\item Without maintaining the reciprocity between binary code and the data it operates on, the semeiosis performed by the end user on the result of the data processing and their subsequent semantics cannot be guaranteed to be similar as intended by the software engineer.}
\par\plain {\f0\fs24\b0\i0 \\end\{enumerate\}}
\par\plain {\f0\fs24\b0\i0 \\textbf\{Implications:\}}
\par\plain {\f0\fs24\b0\i0 \\begin\{enumerate\}}
\par\plain {\f0\fs24\b0\i0 \\item The coherence principle is a necessary condition for supporting semantic interoperability;}
\par\plain {\f0\fs24\b0\i0 \\item Each and every reference to the reality that is made by the software agent shall be made in terms of the data tokens that stem from the ASM;}
\par\plain {\f0\fs24\b0\i0 \\item The scope of semantic validity \\& accuracy is to be addressed explicitly such that it can be referred to;}
\par\plain {\f0\fs24\b0\i0 \\item Reuse of data often implies reuse of the data processing code, and vice versa. Having established explicit coherence improves the quality of data and code reuse, and facilitates the verification that the scope of the semantic validity \\& accuracy applies in a new context as well;}
\par\plain {\f0\fs24\b0\i0 \\item manageability ...?}
\par\plain {\f0\fs24\b0\i0 \\item understandability ...?}
\par\plain {\f0\fs24\b0\i0 \\end\{enumerate\}  }
\par\plain {\f0\fs24\b0\i0 \\end\{mmdp\}}
\par\pard\plain \ri-16872\ql\ltrch\loch \f0\fs24\b0\i0
\par\plain {\f0\fs24\b0\i0 Coherence between models can be established with use of a single unique reference against which the truth of the expressions of both models can be verified. In semiotics, this single unique reference is considered reality, as indicated in \\cref\{fig:semiotic-triangles\}(b) by the *trueness* characteristic. Except as toy example in [@Steels:2008tr], this is clearly not possible. The *correctness* characteristic is the only alternative left, taking the conceptualisation node as its principle point of reference, as depicted in \\cref\{fig:single-semantic-reference\}(b). This is exactly what the mathematical branch of *formal semantics* achieves [@Gamut1991; @Genesereth:1987dg] with its three main characteristics, depicted in \\cref\{fig:single-semantic-reference\}(a), viz. connecting (i) an abstract syntax of a language to (ii) a Domain of Interpretation (DoI, usually a set theoretic framework) by defining (iii) an interpretation function from the abstract syntax onto the set theoretic framework. In terms of the semiotic triangle, \\cref\{fig:semiotic-triangles\}(b), this implies the following:}
\par\plain \f0\fs24\b0\i0
\par\plain {\f0\fs24\b0\i0 (i) a semantic monolith is formulated as two *representation* nodes, each node formulated by use of an abstract syntax (and grammar) as its modelling language. In this reading, a model is a particular constellation of tokens;}
\par\plain {\f0\fs24\b0\i0 (ii) a particular *conceptualisation* is a mathematical formulation as a DoI, viz. specific constellation of (unnamed) individuals, sets of individuals, and sets of sets; }
\par\plain {\f0\fs24\b0\i0 (iii) each *subjectivation* edge is formulated as interpretation function that assigns a mapping from modelling language tokens onto the set elements, enabling the evaluation of a specific model against the intended conceptualisation from (i). }
\par\plain \f0\fs24\b0\i0
\par\plain {\f0\fs24\b0\i0 In this way, the cognitive quality of the conceptualisation can be substituted with a set theoretic mathematical framework. Formulating the conceptualisation as a set theoretic model essentially remains a representation, albeit a mathematical one. One can argue that such substitution does not resolve the grounding problem, and appropriately so. Still, mathematics provide for a very exact way to express oneself, reducing the ambiguity that comes implicitly with any other language, and such mathematical constructs come as close to the conceptualisation as we possibly can get with a token-based machine. Furthermore, logical constructs used at the syntactical level can be interpreted into set theoretic operations, facilitating the evaluation of (complicated) expressions. Formal semantics thus provides a single DoI about a particular conceptualisation as principle point of reference for both the data model and the data processing model. The particular conceptualisation is then replaced with a particular DoI, and both subjectivation relations are replaced with their interpretation function for the abstract syntax of the models on that DoI. This has been depicted in \\cref\{fig:single-semantic-reference\}.}
\par\pard\plain \ltrch\loch \f0\fs24\b0\i0
\par\pard\plain \ri-16872\ql\ltrch\loch {\f0\fs24\b0\i0 ![Maintaining the reciprocity between data and data processing models through a single semantic reference, viz. the conceptualisation (b), represented as DoI, viz. a selection of individuals with domain specific characteristics defined as sets (a).][def:ssref]}
\par\plain \f0\fs24\b0\i0
\par\plain {\f0\fs24\b0\i0 In conclusion, we explain software semantics as the reciprocity between data and software code, realised by maintaining the coherence between pairs of data and data processing models, by applying formal semantics to formulate a particular conceptualisation as the DoI that can act as semantic reference, and interpretation functions which perform the subjectivation from the data and operation models to that reference.}
\par\pard\plain \ltrch\loch \f0\fs24\b0\i0
\par\pard\plain \ql\ltrch\loch {\f0\fs24\b0\i0 The notion on semantic coherence can be seen in object-orientation (OO) as well, where the class can be seen as a construct similar to a semantic monolith. Indeed, OO does a very good job at enforcing a reciprocity between data and data operations. However, as a model OO can only provide for an informal \loch\af0\hich\af0\dbch\af0\uc1\u8220\'93representation\u8221\'94 relation with reality as depicted in \\cref\{fig:software-models-reality\} due to the absence of a formal underlying framework and, henceforth, absence of a formal DoI. As we will see in \\cref\{explicit-semantics\}, OO makes a good instrument for maintaining coherence, but cannot represent semantics explicitly. }
\par\pard\plain \ri-16872\ql\ltrch\loch \f0\fs24\b0\i0
\par\pard\plain \ltrch\loch {\f0\fs24\b0\i0 <2nd Principle: Make the ASM as small as possible, but not smaller than required to express a semantic element. Too vague, yet. Not necessary to convey the primary message, imo.>}
\par\plain \f0\fs24\b0\i0
\par\plain \f0\fs24\b0\i0
\par\pard\plain \ql\ltrch\loch {\f0\fs24\b0\i0 <!-- page additions -->}
\par\pard\plain \ri-10760\ql\ltrch\loch {\f0\fs24\b0\i0 [def:softmodelsreal]: src\\images\\SoftwareModelsReality.png \{#fig:software-models-reality\}}
\par\pard\plain \ri-16872\ql\ltrch\loch {\f0\fs24\b0\i0 [def:ssref]: src\\images\\SingleSemanticReference.png \{#fig:single-semantic-reference\}}
\par\plain \f0\fs24\b0\i0}