{\rtf1\ansi\ansicpg1252\uc1\deff0
{\fonttbl{\f0\fnil\fcharset0\fprq2 MS Shell Dlg 2;}{\f1\fmodern\fcharset0\fprq2 CourierNewPSMT;}}
{\colortbl;\red0\green0\blue0;\red255\green255\blue255;}
\paperw12240\paperh15840\margl1800\margr1800\margt1440\margb1440\fet2\ftnbj\aenddoc
\pgnrestart\pgnstarts0
\pard\plain \ri-17683\ql\ltrch\loch {\f1\fs24\b0\i0 We have founded our work on the discipline of semiotics with the conclusion that genuine semantics cannot exist in software as it exists today. Indeed this comes very close to the debate that followed Searle\loch\af1\hich\af1\dbch\af1\uc1\u8217\'92s Chinese room experiment [@Searle:1980hw] on the (im)possibility for computers to think and understand. According to [Ch.1 in @Cole2020] this debate is still going strong with minimally 2000 works over the last decade. It is not our intention to partake in this debate but to assume the position taken and investigate its consequences. We consider the outcome of the investigation, viz. the 5 \\cref\{dp:semiotic-pragmatic,dp:comprehension-behaviour,dp:reciprocity,dp:atomicity,dp:semantic-coherence\}, sufficiently valuable to pursue the consequences of its main outcome, the reciprocity principle, in software architecture. The results are laying in front of you.}
\par\pard\plain \ri-17683\ltrch\loch {\f1\fs24\b0\i0  }
\par\pard\plain \ri-17683\ql\ltrch\loch {\f1\fs24\b0\i0 Indeed, in contrast with [@Steels:2008tr] we do not claim to have solved the symbol grounding problem and nor did we intend to. We defend that such is not necessary anymore once the premise that semantics cannot exist in software is assumed. With the subsequent conclusion that the reciprocity between data and data processing is the next best thing towards semantics, we have shown that our definitions on token and model grounding \\cref\{def:token-grounding,def:model-grounding\} suffice for establishing the reduced form of grounding as specified in \\cref\{dp:semantic-grounding\}. Although the token-based machine that contemporary software represents is denied genuine semantics, the principles do consolidate a consistent and coherent representation of semantic and pragmatic meaning into a single distinct, tangible and computational artifact. We further claim that our proposal for a semantic viewpoint and view that follow those principles provides practical guidance towards engineering semantic services from which, eventually, semantic standards can emerge that allow for their embedding into the infrastructure, the approach that is the fundamental instrument to the continuous, stable growth of ICT in the last 6 decades.}
\par\pard\plain \ri-17683\ltrch\loch {\f1\fs24\b0\i0  }
\par\pard\plain \ri-17683\ql\ltrch\loch {\f1\fs24\b0\i0 \\Cref\{dp:comprehension-behaviour\} calls for a clear boundary to exist between behaviour and comprehension. We admit that this boundary is not fully characterised, yet. More research is required to establish a proper principled approach. And although its principled approach is underdeveloped by the current \\cref\{heur:how-to-discern\}, at first glance impediments nor conflicts seem to emerge.}
\par\pard\plain \ri-17683\ltrch\loch {\f1\fs24\b0\i0                }
\par\pard\plain \ri-17683\ltrch\loch {\f1\fs24\b0\i0 In [@Lankhorst2017, sec.3.3], the authors emphasise the importance of semantics and argue that distinct views still have something in common, namely the semantics of the architecture. They position semantics as the interpretation of symbolic models, an abstraction of reality that can only refer to reality by interpreting the symbols of the symbolic model. They denote the interpretation of the symbols and the symbolic models the *semantic model*. We can only concur with their note that interpretation is performed by stakeholders of the system and architecture,  their latter view which overlaps with our conclusion that semantics do not exist in software. Based on this explanation of the semantics of the architecture, one might debate the necessity of a semantic view; after all, formal semantics of a symbolic model exists as a concrete collection of mathematical objects interpreting a system according to a specific architecture description. Our dispute with that view is twofold: firstly, we consider semantics a concern shared by many stakeholders and therefore significant for understanding their commonalities as well as their differences. Consequently, its distribution over all interpretations of all symbolic models breaks the principles of separation of concerns, coherence and consistency. Secondly, as described by the authors we understand that the focus for semantics is on the system as part of reality that realises the demands of the domain of application. We argue, contrarily, that the focus for semantics should be the domain of application and that the resulting domain model represents the grounding for all other models of the system. The underlying concern is not only the ability to communicate about the domain of application, but also the appropriateness of the system artifacts to represent the domain accurately, and the internal consistency with which the architecture addresses the various stakeholder concerns that have something in common indeed: the domain of application. The main principles in support of this argument are \\cref\{dp:language-appropriateness,dp:domain-faithfulness\}.}
\par\pard\plain \ri-17683\ltrch\loch {\f1\fs24\b0\i0  }
\par\pard\plain \ri-17683\ql\ltrch\loch {\f1\fs24\b0\i0 Despite our analysis that including the three distinct facets of the semantic service represent a necessary condition for the semantic component, it remains unclear whether their inclusion is a sufficient condition as well. Therefore, this aspect needs to become subject to further investigations and experiences.}
\par\pard\plain \ri-17683\ltrch\loch {\f1\fs24\b0\i0  }
\par\pard\plain \ri-17683\ql\ltrch\loch {\f1\fs24\b0\i0 The notion on semantic coherence can be seen in object-orientation (OO) as well, where the class can be seen as a construct similar to a semantic monolith. Indeed, OO does a very good job at enforcing reciprocity between data and data operations. However, as a model OO can only provide for an informal \loch\af1\hich\af1\dbch\af1\uc1\u8220\'93representation\u8221\'94 relation with reality as depicted in \\cref\{fig:software-models-reality\} due to the absence of a formal underlying framework and, henceforth, absence of a formal DoI. OO makes a good instrument for maintaining coherence, but cannot represent semantics explicitly.}
\par\pard\plain \ri-17683\ltrch\loch {\f1\fs24\b0\i0  }
\par\plain {\f1\fs24\b0\i0 The notion of Domain Model is not new in software engineering, and in Domain-Driven Design (DDD) [@Evans2003] it is the pillar of software development: the implementation is directly connected to a model of the core business concepts (core domain and domain logic). It is supposed to bring its full value when addressing complex business needs. It is however an approach and does not provide actual method or tool to apply the design practices. Although DDD acknowledges the importance of the Domain Model in designing and implementing software system, it does not put the same importance to the technical concerns of the system. Model-driven engineering and model-driven architecture (MDE/MDA) also emphasizes the importance of the domain model: in MDA (https://www.omg.org/mda/), the Computer Independent Model (CIM)is the first model to design. The technical concerns are then addressed from the CIM in the chain of transformation (from platform independence to platform specificities). MDE [@Bezivin2006] generalises the MDA approach, with the coexistence of various models describing the system, especially to address the multiple technical concerns through model transformation. Although those software engineering paradigms acknowledge the importance of the Domain Model, they do not provide neither a definition of what the domain model is, nor design principles to develop it. Our proposal contributes to model-driven approaches with a clear definition of the semantic view and the principles associated with its governing viewpoint.  }
\par\pard\plain \ri-17683\ql\ltrch\loch {\f1\fs24\b0\i0 Regarding future work, based on this work we will investigate its consequences in semantic interoperability, and establish how that can be consolidated into contemporary software architectures. Another relevant line of investigation is the further elaboration of the principles into a concrete semantic viewpoint and a subsequent design of an effective semantic view for a particular use case.}
\par\pard\plain \ri-17683\ltrch\loch {\f1\fs24\b0\i0  }
\par\pard\plain \ri-17683\ltrch\loch {\f1\fs24\b0\i0 In conclusion, we introduce three concerns that are involved with semantics in software. The *semiotic and pragmatic concern* concludes that in software, semantics is reduced to the reciprocity between data and software code for which we assign an Atomic Semantic Monolith (ASM), and we introduce 5 design principles to its effect. The *domain appropriateness concern* establishes that a modelling language itself already contributes to semantics, and identify 2 design principles to consolidate that characteristic in a Domain Model. Finally, the *architectural consistency concern* addresses how the software agent can effectively apply the Domain Model to reflect the state of affairs in reality as well as its particular knowledge, and we identify 2 design principles to maintain its loosely coupled and consistent use by the agent\loch\af1\hich\af1\dbch\af1\uc1\u8217\'92s other models. We validate these concerns and design principles by showing how they commit to the requirements that are established by ISO42010 about an architectural viewpoint and view. We consider the 3 concerns and 9 design principles the necessary an sufficient conditions to consolidate semantics in contemporary software architecture, and are confident that they contribute to the scientific consensus on semantics in software that is necessary to their abstraction as semantic services into the infrastructure.}
\par\pard\plain \ri-17683\ltrch\loch {\f1\fs24\b0\i0            }
\par\plain \f1\fs24\b0\i0}